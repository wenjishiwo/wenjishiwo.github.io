{"pages":[],"posts":[{"title":"页面问题","text":"##关于博客页面在移动端 ##和pc端的页面显示不全的解决方法真的非常搞笑的一件事情，我的博客在移动端和pc端会出现非常大的差异。由于hexo自身渲染的原因，而相关文件是用markdown语法来写，但是很多文件并不全是。除了md这个内容的文件外，页面还是要用到html的相关语句。但是与传统的html文件不同，这个是渲染生成index.html,所以找不到相关的html文件。有的html文件都是之前hexo渲染生成的临时文件，所以修改没有任何作用。之后我以为是代码的问题，主要是认为估计可能是display化后造成的边框溢出。最后通过google的开发者的调试模式，一直在调试具体两个模块的代码，不管如何调都是没法改变，由于是body主体已经将整个代码都display了，所以最后是很无奈的。之后通过百度和Google,发现这样的问题并不普遍。最后发现有关网页说，无论是电脑还是手机，要做到自适应屏幕，其实都是一样的。首先，在网页代码的头部，加入一行viewport标签 viewport是网页默认的宽度和高度，上面这行代码的意思是，网页宽度默认等于屏幕宽度（width=device-width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。即让viewport的宽度等于物理设备上的真实分辨率，不允许用户缩放。之后我开始找有关渲染的原始文件，通过搜索关键字viewport,发现在Hexo\\themes\\有关theme\\layout_partial的header.ejs文件里面有相关的html代码，发现里面已经定义了这个标签，发现width=device-width这个条件于是我将相关代码补全，然后没有用。最后，我仔细发现看来是这个标签的原因，这个标签是为了适配两种设备。于是我试了下将这个标签去掉，让其自然显示，发现果然解决了问题。终于移动端和pc端都可以使用相关的所有功能。","path":"2018/09/23/jiejue/"},{"title":"今天是我的生日","text":"不知不觉到了自己的生日，想写点什么，毕竟感觉自己真的是不小了。今天收到来自同学们的祝福，内心还是挺开心的，大家平时互相帮助互相共事的情景还是非常快乐的。过生肯定首先要想到家人，我妈给我发个大红包，还是挺开心的。昨天还看了风语咒，感慨真的是家人带给我很多东西。今天生日收到我姐的月饼，也是非常开行，谢谢我姐对我的照顾，真的是太感谢我姐了。然后整个宿舍决定庆祝一下，最后点了肯德基来庆祝，还是非常有意思的，今天还没结束，但是我还是想写下来，晚上接着出去吃！到时候再来更新！","path":"2018/09/23/shenri/"},{"title":"风语咒","text":"今天在网上看了一下国产动漫电影《风语咒》，实话看了之后。感觉还是不错的，没想到剧情还是可以的。感觉国漫有希望了，和之前《大鱼海棠》比，是两种不同风格的电影。这个电影的很多特效技术，说实话也就是画风真的是国内的极致。虽然从中可以看到很多电影的影子，但是并没有落入俗套，看了之后，尤其对其中的感人情节记忆很深，让我也感受到这部片子想带给我的东西。真的不错，动漫迷真的可以看下。","path":"2018/09/22/tupian/"},{"title":"poj2377 最小生成树 负数化变成最大生成树 prime算法实践","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define INF 1&lt;&lt;30#define maxn 1010using namespace std;int G[maxn+1][maxn+1];int intree[maxn];int minweight[maxn];int sumweight;int flag=0;void chushihua()&#123; memset(intree,0,sizeof(intree)); memset(minweight,0,sizeof(minweight)); flag=0; for(int i=0;i&lt;maxn;i++) &#123; for(int j=0;j&lt;=maxn;j++) &#123; G[i][j]=INF; &#125; &#125; sumweight=0;&#125;void prime(int n)&#123; int node,Minweight; for(int i=1;i&lt;=n;i++) minweight[i]=G[1][i]; intree[1]=1; for(int i=2;i&lt;=n;i++) &#123; Minweight=INF; for(int j=1;j&lt;=n;j++) &#123; if(minweight[j]&lt;Minweight&amp;&amp;!intree[j]) &#123; Minweight=minweight[j]; node=j; &#125; &#125; intree[node]=1; sumweight+=Minweight; for(int j=1;j&lt;=n;j++) &#123; if(!intree[j]&amp;&amp;minweight[j]&gt;G[node][j]) &#123; minweight[j]=G[node][j]; &#125; &#125; &#125;&#125;int main()&#123; int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF) &#123; int a1,a2,v; chushihua(); for(int i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a1,&amp;a2,&amp;v); G[a1][a2]=-v; G[a2][a1]=-v; &#125; prime(n); for(int i=1;i&lt;=n;i++) &#123; if(intree[i]==0) &#123;flag=1; break;&#125; &#125; if(flag) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;,-sumweight); &#125; return 0; &#125;","path":"2018/09/21/du11/"},{"title":"hdu2066 Dijkstra 最短路 无向图版本 板子修改","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int map[1111][1111];int dis[1111];int book[1111];int maxn=1&lt;&lt;30;int main()&#123; int t,s,d; while(cin&gt;&gt;t&gt;&gt;s&gt;&gt;d) &#123; int minnn; for(int i=0;i&lt;=1110;i++) for(int j=0;j&lt;=1110;j++) if(i==j) map[i][j]=0; else map[i][j]=maxn; for(int i=1;i&lt;=t;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; map[a][b]=min(map[a][b],c); map[b][a]=map[a][b]; &#125; for(int i=0;i&lt;=1110;i++) book[i]=0; book[0]=1; for(int i=1;i&lt;=s;i++) &#123; int a; cin&gt;&gt;a; map[0][a]=map[a][0]=0; &#125; for(int i=0;i&lt;=1110;i++) &#123; dis[i]=map[0][i]; &#125; int u; for(int i=1;i&lt;=1110;i++) &#123; minnn=maxn; for(int j=1;j&lt;=1110;j++) &#123; if(book[j]==0&amp;&amp;dis[j]&lt;minnn) &#123; minnn=dis[j]; u=j; &#125; &#125; book[u]=1; for(int v=1;v&lt;=1110;v++) &#123; if(dis[v]&gt;dis[u]+map[u][v]&amp;&amp;!book[v]) dis[v]=dis[u]+map[u][v]; &#125; &#125; int minn=maxn; for(int i=1;i&lt;=d;i++) &#123; int a; cin&gt;&gt;a; minn=min(dis[a],minn); &#125; cout&lt;&lt;minn&lt;&lt;endl;&#125; return 0;&#125;","path":"2018/09/21/du10/"},{"title":"Dijkstra 最短路 有向图版本板子 无向图就是双重附边","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 #include &lt;stdio.h&gt; int main() &#123; int e[10][10],dis[10],book[10],i,j,n,m,t1,t2,t3,u,v,min; int inf=99999999; //用inf(infinity的缩写)存储一个我们认为的正无穷值 //读入n和m，n表示顶点个数，m表示边的条数 scanf(&quot;%d %d&quot;,&amp;n,&amp;m); //初始化 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) if(i==j) e[i][j]=0; else e[i][j]=inf; //读入边 for(i=1;i&lt;=m;i++) &#123; scanf(&quot;%d %d %d&quot;,&amp;t1,&amp;t2,&amp;t3); e[t1][t2]=t3; &#125; //初始化dis数组，这里是1号顶点到其余各个顶点的初始路程 for(i=1;i&lt;=n;i++) dis[i]=e[1][i]; //book数组初始化 for(i=1;i&lt;=n;i++) book[i]=0; book[1]=1; //Dijkstra算法核心语句 for(i=1;i&lt;=n-1;i++) &#123; //找到离1号顶点最近的顶点 min=inf; for(j=1;j&lt;=n;j++) &#123; if(book[j]==0 &amp;&amp; dis[j]&lt;min) &#123; min=dis[j]; u=j; &#125; &#125; book[u]=1; for(v=1;v&lt;=n;v++) &#123; if(e[u][v]&lt;inf) &#123; if(dis[v]&gt;dis[u]+e[u][v]) dis[v]=dis[u]+e[u][v]; &#125; &#125; &#125; //输出最终的结果 for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,dis[i]); getchar(); getchar(); return 0; &#125;/*可以输入以下数据进行验证。第一行两个整数 n m。n 表示顶点个数（顶点编号为 1~n），m 表示边的条数。接下来 m 行表示，每行有 3 个数 x y z。表示顶点 x 到顶点 y 边的权值为 z。 6 9 1 2 1 1 3 12 2 3 9 2 4 3 3 5 5 4 3 4 4 5 13 4 6 15 5 6 4运行结果是 0 1 8 4 13 17*/","path":"2018/09/21/du9/"},{"title":"线段树板子","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000010;int A[maxn];struct dian&#123; int l,r; int d; int lazy;&#125;sum[maxn&lt;&lt;2];void pushup(int rt)&#123; sum[rt].d=max(sum[rt&lt;&lt;1].d,sum[rt&lt;&lt;1|1].d);&#125;void build(int l,int r,int rt)&#123; sum[rt].l=l; sum[rt].r=r; sum[rt].d=0; sum[rt].lazy = 0; if(l!=r) &#123; int mid=(l+r)&gt;&gt;1; build(l,mid,rt&lt;&lt;1); build(mid+1,r,rt&lt;&lt;1|1); &#125;&#125;void xiachuan(int rt)&#123; sum[rt&lt;&lt;1].lazy+=sum[rt].lazy; sum[rt&lt;&lt;1|1].lazy+=sum[rt].lazy; sum[rt&lt;&lt;1].d+=sum[rt].lazy; sum[rt&lt;&lt;1|1].d+=sum[rt].lazy; sum[rt].lazy=0;&#125;void cha(int l,int r,int rt)&#123; if(sum[rt].l==l&amp;&amp;sum[rt].r==r) &#123; sum[rt].d++; sum[rt].lazy++; return; &#125; if(sum[rt].lazy) xiachuan(rt); int mid=(sum[rt].l+sum[rt].r)&gt;&gt;1; if(r&lt;=mid) cha(l,r,rt&lt;&lt;1); else if(l&gt;mid) cha(l,r,rt&lt;&lt;1|1); else &#123; cha(l,mid,rt&lt;&lt;1); cha(mid+1,r,rt&lt;&lt;1|1); &#125; pushup(rt);&#125;int query(int l,int r,int rt)&#123; if(sum[rt].l==l&amp;&amp;sum[rt].r==r) return sum[rt].d; if(sum[rt].lazy) xiachuan(rt); int mid=(sum[rt].r+sum[rt].l)&gt;&gt;1; if(r&lt;=mid) return query(l,r,rt&lt;&lt;1); else if(l&gt;mid) return query(l,r,rt&lt;&lt;1|1); else return max(query(l,mid,rt&lt;&lt;1),query(mid+1,r,rt&lt;&lt;1|1));&#125;int main()&#123; int k,m; int a,b; memset(A,0,sizeof(A)); scanf(&quot;%d%d&quot;,&amp;k,&amp;m); build(1,1000000,1); int id=0; for(int i=0;i&lt;m;i++) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); b--; if(query(a,b,1)&lt;k) &#123; A[id++]=i+1; cha(a,b,1); &#125; &#125; for(int i=0;i&lt;id;i++) printf(&quot;%d &quot;,A[i]); return 0;&#125;","path":"2018/09/21/du8/"},{"title":"contest1 hdu3635 drahonball 并查集升级版本 理解并查集基本概念和应用","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;//龙珠和城市都有区分 int gen[10010];//龙珠附属于某个城市 int num[10010];//龙珠移动次数 int rankk[10010];//所在城市的龙珠数int find(int x)&#123; int r=x; while(r!=gen[r]) &#123; num[r]+=num[gen[r]]; r=gen[r]; &#125; int i=x,j; while(i!=r) &#123; j=gen[i]; gen[i]=r; i=j; &#125;&#125; void join(int a,int b)&#123; int fx=find(a); int fy=find(b); if(fx!=fy) &#123; gen[fx]=fy; rankk[fy]+=rankk[fx]; num[fx]=1; &#125;&#125;int main()&#123; int N; cin&gt;&gt;N; int ttt=0; while(N--) &#123; int n,m; ttt++; cin&gt;&gt;n&gt;&gt;m; string caozuo; for(int i=1;i&lt;=n;i++) &#123; gen[i]=i; num[i]=0; rankk[i]=1; &#125; for(int i=1;i&lt;=m;i++) &#123; int a,b; cin&gt;&gt;caozuo; if(caozuo==&quot;T&quot;) &#123; cin&gt;&gt;a&gt;&gt;b; join(a,b); &#125; else &#123; cin&gt;&gt;a; int temp=find(a); cout&lt;&lt;&quot;Case &quot;&lt;&lt;ttt&lt;&lt;&quot;:&quot;&lt;&lt;endl&lt;&lt;temp&lt;&lt;&quot; &quot;&lt;&lt;rankk[temp]&lt;&lt;&quot; &quot;&lt;&lt;num[a]&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125;","path":"2018/09/21/du7/"},{"title":"并查集基础题hdu1232畅通工程详解附带模板","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt; using namespace std;int pre[1010];int flag[1010];//判断是否是根节点 int find(int x)&#123; int r=x; while(pre[r]!=r) &#123; r=pre[r]; &#125; int i=x; int j; while(i!=r) //路径压缩 &#123; j=pre[i]; pre[i]=r; i=j; &#125; return r;&#125;void join(int x,int y) //判断是否均为联通分支，并且进行合并 &#123; int fx=find(x); int fy=find(y); if(fx!=fy) &#123; pre[fx]=fy; &#125;&#125;int main()&#123; int N,M; int a,b; int total; while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)&amp;&amp;N) &#123; for(int i=1;i&lt;=N;i++) &#123; pre[i]=i; &#125; for(int i=1;i&lt;=M;i++) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); join(a,b); &#125; memset(flag,0,sizeof(flag)); for(int i=1;i&lt;=N;i++) &#123; int gen=find(i); flag[gen]=1; &#125; total=0; int shu=0;//根节点的数目 for(int i=1;i&lt;=N;i++) &#123; if(flag[i]) &#123; shu++; &#125; &#125; total=shu-1;//易错，不能写成shu--,因为运算的优先性 printf(&quot;%d\\n&quot;,total); &#125; return 0;&#125; contest1 rumor 并查集基础变式练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt; typedef long long ll;using namespace std;int pre[100010];ll gold[100010];int vis[100010];//判断是否是根节点 int find(int x)&#123; int r=x; while(pre[r]!=r) &#123; r=pre[r]; &#125; int i=x,j; while(i!=r) &#123; j=pre[i]; pre[i]=r;//易错，不是r=pre[i],而是pre[i]=r; i=j; &#125; return r;&#125;void join(int a,int b)&#123; int fx=find(a); int fy=find(b); if(fx!=fy) &#123; pre[fx]=fy; &#125;&#125;int main()&#123; int N,M; ll total; while(cin&gt;&gt;N&gt;&gt;M) &#123; for(int i=1;i&lt;=N;i++) &#123; cin&gt;&gt;gold[i];//lld的输入不用scanf,而是用cin,或者是%I64d这样。 &#125; for(int i=1;i&lt;=N;i++) &#123; pre[i]=i; &#125; for(int i=1;i&lt;=M;i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; join(a,b); &#125; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=N;i++) &#123; int gen=find(i); vis[gen]=1; gold[gen]=min(gold[gen],gold[i]);//本题易错，这里是一个易错点。 &#125; total=0; for(int i=1;i&lt;=N;i++) &#123; if(vis[i]) &#123; total+=gold[i]; &#125; &#125; cout&lt;&lt;total&lt;&lt;endl; &#125; return 0;&#125;","path":"2018/09/21/du6-1/"},{"title":"contest1 hdu1873优先队列的结构体应用题","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;class bingren&#123;public: int id; int youxianji; friend bool operator &lt; (const bingren &amp;a,const bingren &amp;b) //比较奇怪的一个地方，只有加上const 才可以过，也可以直接(bingren a,bingren b); &#123; if(a.youxianji!=b.youxianji) return a.youxianji&lt;b.youxianji; else return a.id&gt;b.id;&#125;&#125;;int num=0;int main()&#123; int N; while(cin&gt;&gt;N) &#123; num=0; priority_queue&lt;bingren&gt; q[4]; string s1; int a,b; while(N--) &#123; cin&gt;&gt;s1; if(s1==&quot;IN&quot;) &#123; cin&gt;&gt;a&gt;&gt;b; bingren tt; num++; tt.youxianji=b; tt.id=num; q[a].push(tt); //队列入队时push,不是input &#125; else &#123; cin&gt;&gt;a; if(!q[a].empty()) &#123; bingren tm=q[a].top(); q[a].pop(); cout&lt;&lt;tm.id&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;EMPTY&quot;&lt;&lt;endl; &#125; &#125; &#125; &#125; return 0; &#125;","path":"2018/09/21/du6/"},{"title":"set练习题","text":"丑数 优先队列和set查重count练习123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;set&gt;using namespace std;typedef long long ll;//此题易错是long long 不是int int main()&#123; ll n; int factor[3]=&#123;2,3,5&#125;; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; priority_queue&lt;ll,vector&lt;ll&gt;, greater&lt;ll&gt; &gt; q1; set&lt;ll&gt; q2; q1.push(1); q2.insert(1); ll i; for(i=1;;i++) &#123; ll m1=q1.top(); q1.pop(); if(i==n) &#123; printf(&quot;%lld\\n&quot;,m1); break; &#125; for(int j=0;j&lt;3;j++) &#123; ll m2=m1*factor[j]; if(!q2.count(m2)) &#123; q1.push(m2); q2.insert(m2); &#125; &#125; &#125; &#125; return 0;&#125; set对结构体排序的常见用法和排序插件cmp的用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;cstdio&gt;using namespace std;struct Student&#123; int id; string name;&#125;stu1,stu2,stu3;struct setcmp//set容器的插件,来确定set内部的排序 &#123; bool operator()(Student a,Student b) &#123; return a.id&gt;b.id; //这个大括号不可以省略，不然会报错的 &#125;&#125;;struct Setcmp&#123; bool operator()(Student a,Student b) &#123; return a.id&lt;b.id; &#125;&#125;; int main()&#123; set&lt;Student,setcmp&gt; my; set&lt;Student&gt;::iterator it; stu1.id=1000; stu2.id=2000; stu3.id=3000; stu1.name=&quot;ddd&quot;; stu2.name=&quot;www&quot;; stu3.name=&quot;aaa&quot;; my.insert(stu1); my.insert(stu2); my.insert(stu3); for(it=my.begin();it!=my.end();it++) &#123; cout&lt;&lt;it-&gt;id&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;name&lt;&lt;endl; &#125; set&lt;Student,Setcmp&gt; mm; mm.insert(stu1); mm.insert(stu2); mm.insert(stu3); for(it=mm.begin();it!=mm.end();it++) &#123; cout&lt;&lt;it-&gt;id&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;name&lt;&lt;endl; &#125; return 0;&#125; uva10815 set练习以及输入流sstream中的stringstream1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;string&gt; str; string s; while(cin&gt;&gt;s) &#123; for(int i=0;i&lt;s.length();i++) &#123; if(isalpha(s[i])) &#123; s[i]=tolower(s[i]); &#125; else &#123; s[i]=&apos; &apos;;//一个字符空格时&apos; &apos;不是&quot; &quot;; 输入的非字符转换为空格，作为单词的分界点 &#125; &#125; stringstream ss(s);//流 ; //构造时就写进，因为时对象的原因，将s加入ss流类里面,就类似于文件里面的输入文件一样 string s2; while(ss&gt;&gt;s2) &#123; str.insert(s2); &#125; &#125; for(set&lt;string&gt;::iterator it=str.begin();it!=str.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; return 0;&#125;","path":"2018/09/21/du5/"},{"title":"北大暑校","text":"我只是想谈一谈在北大暑校的事。 首先，说一下如何申请，先上北大暑校网站进行申请， 这里面你需要提供详细个人信息以及你的大学成绩单。 如果成绩还可以或是211或985院校，那么应该是很容易 审核通过，当然申请里面的表格等文件要填的越多越好， 来提高申请成功率。大概一周以内，你提交的申请就能 审核通过。 之后你就可以进行选课了，什么样的课都有，而且获得 的学分，拿会学校是基本认可的，也就是可以转到本校 教务系统。 我在暑校的感受是我是非常开心的，见到了视频里面才能见到的 大牛郭玮老师，然后品尝到了北大的食堂，然后还获得了 一个北大暑校证件，可以随时不用预约就能进北大校园。 想想还是挺不错的，虽然自己没学到啥，但是感受一下 国内知名顶尖高校的氛围还是不错的。而且我也亲眼见到 北大计算机获得各种奖状，而且在他们的机房参加了一次 考试，体验挺好。","path":"2018/09/20/beidashuxiao/"},{"title":"map和set","text":"##map 数据结构常见用法代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;iterator&gt;using namespace std;typedef map&lt;int,string,less&lt;int&gt; &gt;M_TYPE;//less greater 都是算子，针对键值来的 默认排序其实也就是key值的升序 ，也就是less&lt;int&gt; typedef M_TYPE::iterator M_IT;int main()&#123; M_TYPE Map; Map[1]=&quot;no.1&quot;; Map[2]=&quot;no.2&quot;; Map[3]=&quot;no.3&quot;; Map[4]=&quot;no.4&quot;; Map[5]=&quot;no.5&quot;; M_IT it=Map.find(2); cout&lt;&lt;&quot;map[2]是&quot;&lt;&lt;it-&gt;second&lt;&lt;endl; Map.insert(make_pair(2,&quot;new no.2&quot;));//不能改变已有的，可以添加没有的 Map.insert(make_pair(6,&quot;no.6&quot;)); Map.insert(pair&lt;int,string&gt;(7,&quot;no.7&quot;)); cout&lt;&lt;&quot;新的map[2]是&quot;&lt;&lt;it-&gt;second&lt;&lt;endl; M_IT is=Map.find(2); cout&lt;&lt;&quot;新的map[2]是&quot;&lt;&lt;is-&gt;second&lt;&lt;endl; it-&gt;second=&quot;new new no.2&quot;;//可以修改原有的 cout&lt;&lt;&quot;最新的map[2]是&quot;&lt;&lt;it-&gt;second&lt;&lt;endl; for(M_IT tt= Map.begin();tt!=Map.end();tt++) &#123; cout&lt;&lt;tt-&gt;second&lt;&lt;endl; &#125; Map.erase(2); cout&lt;&lt;endl; for(M_IT tt= Map.begin();tt!=Map.end();tt++) &#123; cout&lt;&lt;tt-&gt;second&lt;&lt;endl; &#125; cout&lt;&lt;endl; M_IT id=Map.find(5); Map.erase(id); for(M_IT tt= Map.begin();tt!=Map.end();tt++) &#123; cout&lt;&lt;tt-&gt;second&lt;&lt;endl; &#125; return 0;&#125; 水果hdu1263 map内部嵌套用法 简单例题123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;typedef map&lt;string,map&lt;string,int&gt; &gt; MA_P;typedef map&lt;string,int&gt; Ma_P;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; int o; cin&gt;&gt;o; string s1,s2; int k; map&lt;string,map&lt;string,int&gt; &gt;q; for(int i=0;i&lt;o;i++) &#123; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;k; q[s2][s1]+=k;//亲测双重map只能这样用，不能用q.insert(make_pair(s2,make_pair(s1,k)))和pair(XX); &#125; for(MA_P::iterator i=q.begin();i!=q.end();i++) &#123; cout&lt;&lt;i-&gt;first&lt;&lt;endl; for(Ma_P::iterator t=i-&gt;second.begin();t!=i-&gt;second.end();t++) &#123; cout&lt;&lt;&quot; |----&quot;&lt;&lt;t-&gt;first&lt;&lt;&quot;(&quot;&lt;&lt;t-&gt;second&lt;&lt;&quot;)&quot;&lt;&lt;endl; &#125; &#125; if(n&gt;0) cout&lt;&lt;endl; &#125; return 0;&#125; set数据结构常见用法1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;string&gt;strset; set&lt;string&gt;::iterator it; strset.insert(&quot;aa&quot;); strset.insert(&quot;bb&quot;); strset.insert(&quot;cc&quot;); strset.insert(&quot;dd&quot;); for(it=strset.begin();it!=strset.end();it++)//set默认排序为升序，也就是less &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; it=strset.begin(); cout&lt;&lt;&quot;set的第一个元素&quot;&lt;&lt;*it&lt;&lt;endl; it=strset.end(); it--; cout&lt;&lt;&quot;set的最后一个元素&quot;&lt;&lt;*it&lt;&lt;endl; cout&lt;&lt;strset.empty()&lt;&lt;endl; cout&lt;&lt;strset.size()&lt;&lt;endl; cout&lt;&lt;strset.max_size()&lt;&lt;endl;//容器可能包含的元素最大个数 return 0;&#125;","path":"2018/09/20/du4/"},{"title":"priority_queue 练习","text":"##代码 greater算子 #include #includeusing namespace std;class T{ public: int x,y,z; T(int a,int b,int c):x(a),y(b),z(c) { } };bool operator &gt;(const T &amp;t1,const T &amp;t2){ return t1.z&gt;t2.z;}int main(){ priority_queue&lt;T,vector,greater &gt; q; q.push(T(4,4,3)); q.push(T(2,2,5)); q.push(T(1,5,4)); q.push(T(3,3,6)); while(!q.empty()) { T t=q.top(); q.pop(); cout&lt;&lt;t.x&lt;&lt;” “&lt;&lt;t.y&lt;&lt;” “&lt;&lt;t.z&lt;&lt;endl; } return 0;} ##代码 less 算子 #include #includeusing namespace std;class T{ public: int x,y,z; T(int a,int b,int c):x(a),y(b),z(c) { } };bool operator &lt;(const T &amp;t1,const T &amp;t2){ return t1.z&lt;t2.z;}int main(){ priority_queue q; q.push(T(4,4,3)); q.push(T(2,2,5)); q.push(T(1,5,4)); q.push(T(3,3,6)); while(!q.empty()) { T t=q.top(); q.pop(); cout&lt;&lt;t.x&lt;&lt;” “&lt;&lt;t.y&lt;&lt;” “&lt;&lt;t.z&lt;&lt;endl; } return 0;}","path":"2018/09/19/du3-1/"},{"title":"搜索","text":"说起bfs和dfs模板，就是智闯迷宫http://www.bjfuacm.com/problem/62/题目：描述有一个N*M大小的矩阵迷宫，由字符 ’ . ’ 和 ‘ # ’ 组成。起点位于第一行第一列，终点位于最后一行最后一列。想要机智的闯迷宫当然是走最短路径啦！机智的你来算一算迷宫的最短路径吧！(起点为左上角，重点为右下角) 输入有多组测试每组测试第一行输入两个数字N，M（0 &lt; N,M &lt; 20），空格隔开。接下来N行输入N*M大小矩阵。只有字符 ‘ . ’ 和 ‘ # ’ 组成。 ‘ . ’ 表示可以走的路，‘ # ’ 表示高高的障碍物。 输出每组输出从起点到终点的最短路径长度（保证数据每组都有解） 样例输入1 复制3 3………样例输出14样例输入2 复制4 4…. #.##…. #.#.样例输出26 ##代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;using namespace std;char map[22][22];int vis[22][22];int n,m,t=0,l=420;int to[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;/*void dfs(int x,int y)&#123; int tx,ty; t++; for(int i=0;i&lt;4;i++) &#123; tx=x+to[i][0]; ty=y+to[i][1]; if(tx&lt;0||ty&lt;0||tx&gt;=n||ty&gt;=m||map[tx][ty]==&apos;#&apos;||vis[tx][ty]==1) continue; if(map[tx][ty]==&apos;.&apos;&amp;&amp;vis[tx][ty]==0) &#123;vis[tx][ty]=1; if((tx==n-1)&amp;&amp;(ty==m-1)&amp;&amp;t&lt;l) l=t; dfs(tx,ty); &#125; &#125; t--; &#125;*/struct node&#123; int x; int y;&#125;;queue&lt;node&gt;que;void bfs(int x,int y)&#123; struct node q; q.x=x; q.y=y; que.push(q); while(!que.empty()) &#123; q=que.front(); for(int i=0;i&lt;4;i++) &#123; q.x+=to[i][0]; q.y+=to[i][1]; if(q.x&lt;0||q.y&lt;0||q.x&gt;=n||q.y&gt;=m) &#123; continue; &#125; if(map[q.x][q.y]==&apos;#&apos;||vis[q.x][q.y]==1) continue; if(map[q.x][q.y]==&apos;.&apos;&amp;&amp;vis[q.x][q.y]==0) &#123;que.push(q); t++;&#125; if(q.x==n-1&amp;&amp;q.y==m-1) return ; &#125; que.pop(); &#125;&#125;*/int main()&#123; memset(vis,0,sizeof(vis)); while(cin&gt;&gt;n&gt;&gt;m)&#123; l=420; t=0; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;map[i][j]; dfs(0,0); if(n==1&amp;&amp;m==1) l=0; cout&lt;&lt;l&lt;&lt;endl;&#125; return 0;&#125;","path":"2018/09/18/du3/"},{"title":"随笔","text":"我准备整理记录一些以前做过的题，也是为了提醒自己。先从基础知识开始，就从搜索算法开始。","path":"2018/09/17/du2/"},{"title":"计协会长推荐的常用网址（实时更新）","text":"顶尖中文大学计算机专业课程体系https://study.163.com/curricula/cs.htm离散数学 北交大http://www.icourse163.org/course/NJTU-1002530017","path":"2018/09/16/search/"},{"title":"数学和编程","text":"一位大佬的理解（原文摘录）原文链接：https://www.yinwang.org/blog-cn/2015/07/04/math数学和编程好些人来信问我，要成为一个好的程序员，数学基础要达到什么样的程度？十八年前，当我成为大学计算机系新生的时候，也为同样的问题所困扰。面对学数学，物理等学科的同学，我感到自卑。经常有人说那些专业的知识更加精华一些，难度更高一些，那些专业的人毕业之后如果做编程工作，水平其实比计算机系毕业的还要高。直到深入研究程序语言之后，对这个问题我才得到了答案和解脱。由于好多编程新手遇到同样的困扰，所以我想在这里把这个问题详细的阐述一下。 数学并不是计算机科学的基础很多人都盲目的认为，计算机科学是数学的一个分支，数学是计算机科学的基础，数学是更加博大精深的科学。这些人以为只要学会了数学，编程的事情全都不在话下，然而事实却并非如此。 事实其实是这样的： 计算机科学根本不是数学，它只不过借用了非常少，非常基础的数学，比高中数学还要容易。所谓“高等数学”，并不是研究计算机科学必须的。你可以用计算机来做微积分计算，可是这时候你其实是在做数学工作，用计算机作为工具。你研究的并不是计算机科学。这就像你可以用计算机来设计建筑，但建筑学却不是计算机科学的基础。计算机是比数学更加基础的工具，就像纸和笔一样。计算机可以用来解决数学的问题，也可以用来解决不是数学的问题，比如工程的问题，艺术的问题，经济的问题，社会的问题等等。计算机科学是完全独立的学科。学习了数学和物理，并不能代替对计算机科学的学习。你必须针对计算机科学进行学习，才有可能成为好的程序员。数学家所用的语言，比起常见的程序语言（比如C++，Java）来说，其实是非常落后而蹩脚的设计。所谓“数学的美感”，其实大部分是夜郎自大。99% 的数学家都写不出像样的代码。数学是异常糟糕的语言这并不是危言耸听。如果你深入研究过程序语言的理论，就会发现其实数学家们使用的那些符号，其实是一种非常糟糕的程序语言。数学的理论很多是有用的，然而数学家门用于描述这些理论所用的语言，却是纷繁复杂，缺乏一致性，可组合性（composability），简单性，可用性。这也就是为什么大部分人看到数学就头痛。这不是他们不够聪明，而是数学语言的“设计”有问题。人们学习数学的时候，其实只有少部分时间在思考它的精髓，而大部分时间是在折腾它的语法。 举一个非常简单的例子。如果你说 cos2θ 表示 (cos θ)2，那么理所当然，cos-1θ 就应该表示 1/(cos θ) 了？可它偏偏不是！别被数学老师们的教条和借口欺骗啦，他们总是告诉你：“你应该记住这些！” 可是你想过吗：凭什么？ cos2θ 表示 (cos θ)2，而 cos-1θ，明明是一模一样的形式，表示的却是 arccos θ。一个是求幂，一个是调用反函数，风马不及，却写成一个样子。这样的语言设计混淆不堪，却喜欢以“约定俗成”作为借口。 如果你再多看一些数学书，就会发现这只是数学语言几百年累积下来的糟粕的冰山一角。数学书里尽是各种上标下标，带括号的上标下标，x，y，z，a，b，c，f，g，h，各种扭来扭去的希腊字母，希伯来字母…… 斜体，黑体，花体，双影体，……用不同的字体来表示不同的“类型”。很多符号的含义，在不同的子领域里面都不一样。有些人上一门数学课，到最后还没明白那些符号是什么意思。 直到今天，数学家们写书仍然非常不严谨。他们常犯的一个错误是把 x2 这样的东西叫做“函数”（function）。其实 x2 不是一个函数，它只是一个表达式。你必须同时指明“x 是参数”，加上 x2，才会成为一个函数。所以正确的函数写法其实看起来像这样：f(x) = x2。或者如果你不想给它一个名字，可以借用 lambda calculus 的写法，写成： λx.x2。 可是数学家们灰常的喜欢“约定俗成”。他们定了一些不成文的规矩是这样：凡是叫“x”的，都是函数的参数，凡是叫“y”的，都可能是一个函数…… 所以你写 x2 就可以表示 λx.x2，而不需要显式的写出“λx”。殊不知这些约定俗成，看起来貌似可以让你少写几个字，却造成了许许多多的混淆和麻烦。比如，你在 Mathematica 里面可以对 x2 + y 求关于x的导数，而且会得到 y’(x) + 2x 这样蹊跷的结果，因为它认为 y 可能是一个函数。更奇怪的是，如果你在后面多加一个 a，也就是对 x2 + y + a 求导，你会得到 2x！那么 y’(x) 到哪里去了？莫名其妙…… 相对而言，程序语言就严谨很多，所有的程序语言都要求你必须指出函数的参数叫什么名字。像 x2 这样的东西，在程序语言里面不是一个函数（function），而只是一个表达式（expression）。即使 JavaScript 这样毛病众多的语言都是这样。比如，你必须写： function (x) { return x * x }那个括号里的(x)，显式的声明了变量的名字，避免了可能出现的混淆。我不是第一个指出这些问题的人。其实现代逻辑学的鼻祖 Gottlob Frege 在一百多年以前就在他的论文“Function and Concept”里批评了数学家们的这种做法。可是数学界的表达方式直到今天还是一样的混乱。 很多人学习微积分都觉得困难，其实问题不在他们，而在于莱布尼兹（Leibniz）。莱布尼兹设计来描述微积分的语言（∫，dx, dy, …），从现代语言设计的角度来看，其实非常之糟糕，可以说是一塌糊涂。我不能怪莱布尼兹，他毕竟是几百年前的人了，他不知道我们现在知道的很多东西。然而古人的设计，现在还不考虑改进，反而当成教条灌输给学生，那就是不思进取了。 数学的语言不像程序语言，它的历史太久，没有经过系统的，考虑周全的，统一的设计。各种数学符号的出现，往往是历史上某个数学家有天在黑板上随手画出一些古怪的符号，说这代表什么，那代表什么，…… 然后就定下来了。很多数学家只关心自己那块狭窄的子领域，为自己的理论随便设计出一套符号，完全不管这些是否跟其它子领域的符号相冲突。这就是为什么不同的数学子领域里写出同样的符号，却可以表示完全不同的涵义。在这种意义上，数学的语言跟 Perl（一种非常糟糕的程序语言）有些类似。Perl 把各种人需要的各种功能，不加选择地加进了语言里面，造成语言繁复不堪，甚至连Perl的创造者自己都不能理解它所有的功能。 数学的证明，使用的其实也是极其不严格的语言——古怪的符号，加上含糊不清，容易误解的人类语言。如果你知道什么是 Curry-Howard Correspondence 就会明白，其实每一个数学证明都不过是一段代码。同样的定理，可以有许多不同版本的证明（代码）。这些证明有的简短优雅，有的却冗长繁复，像面条一样绕来绕去，没法看懂。你经常在数学证明里面看到“未定义的变量”，证明的逻辑也包含着各种隐含知识，思维跳跃，非常难以理解。很多数学证明，从程序的观点来看，连编译都不会通过，就别提运行了。 数学家们往往不在乎证明的优雅性。他们认为只要能证明出定理，你管我的证明简不简单，容不容易看懂呢。你越是看不懂，就越是觉得我高深莫测，越是感觉你自己笨！这种思潮到了编程的时候就显出弊端了。数学家写代码，往往忽视代码的优雅性，简单性，模块化，可读性，性能，数据结构等重要因素，认为代码只要能算出结果就行。他们把代码当成跟证明一样，一次性的东西，所以他们的代码往往不能满足实际工程的严格要求。 数学里最在乎语言设计的分支，莫过于逻辑学了。很多人（包括很多程序语言专家）都盲目的崇拜逻辑学家，盲目的相信数理逻辑是优雅美好的语言。在程序语言界，数理逻辑已经成为一种灾害，明明很容易就能解释清楚的语义，非得写成一堆稀奇古怪，含义混淆的逻辑公式。殊不知其实数理逻辑也是有很大的历史遗留问题和误区的。研究逻辑学的人经常遇到各种“不可判定”（undecidable）问题和所谓“悖论”（paradox），研究几十年也没搞清楚，而其实那些问题都是他们自己造出来的。你只需要把语言改一下，去掉一些不必要的功能，问题就没了。但逻辑学家们总喜欢跟你说，那是某天才老祖宗想出来的，多么多么的了不起啊，不能改！ 用一阶逻辑（first-order logic）这样的东西，你可以写出一些毫无意义的语句。逻辑老师们会告诉你，记住啦，这些是没有意义的，如果写出来这些东西，是你的问题！他们没有意识到，如果一个人可以用一个语言写出毫无意义的东西，那么这问题在于这个语言，而不在于这个人。一阶逻辑号称可以“表达所有数学”，结果事实却是，没有几个数学家真的可以用它表达很有用的知识。到后来，稍微明智一点的逻辑学家们开始研究这些老古董语言到底出了什么毛病，于是他们创造了 Model Theory 这样的理论。写出一些长篇大部头，用于“验证”这些逻辑语言的合理性。这些问题在我看来都是显而易见的，因为很多逻辑的语言根本就不是很好很有用的东西。去研究它们“为什么有毛病”，其实是白费力气。自己另外设计一个更好语言就完事了。 在我看来，除了现代逻辑学的鼻祖 Gottlob Frege 理解了逻辑的精髓，其它逻辑学家基本都是照本宣科，一知半解。他们喜欢把简单的问题搞复杂，制造一些新名词，说得玄乎其玄灵丹妙药似的。如果你想了解逻辑学的精华，建议你看看 Frege 的文集。看了之后你也许会发现，Frege 思想的精华，其实已经融入在几乎所有的程序语言里了。 编程是一门艺术从上面你也许已经明白了，普通程序员使用的编程语言，就算是 C++ 这样毛病众多的语言，其实也已经比数学家使用的语言好很多。用数学的语言可以写出含糊复杂的证明，在期刊或者学术会议上蒙混过关，用程序语言写出来的代码却无法混过计算机这道严格的关卡。因为计算机不是人，它不会迷迷糊糊的点点头让你混过去，或者因为你是大师就不懂装懂。代码是需要经过现实的检验的。如果你的代码有问题，它迟早会导致出问题。 计算机科学并不是数学的一个分支，它在很大程度上是优于数学，高于数学的。有些数学的基本理论可以被计算机科学所用，然而计算机科学并不是数学的一部分。数学在语言方面带有太多的历史遗留糟粕，它其实是泥菩萨过河，自身难保，它根本解决不了编程中遇到的实际问题。 编程真的是一门艺术，因为它符合艺术的各种特征。艺术可以利用科学提供的工具，然而它却不是科学的一部分，它的地位也并不低于科学。和所有的艺术一样，编程能解决科学没法解决的问题，满足人们新的需求，开拓新的世界。所以亲爱的程序员们，别再为自己不懂很多数学而烦恼了。数学并不能帮助你写出好的程序，然而能写出好程序的人，却能更好的理解数学。我建议你们先学编程，再去看数学。 如果你想了解更多关于数学语言的弊病以及程序语言对它们的改进，我建议你看看这个 Gerald Susman 的讲座。","path":"2018/09/15/ddd/"},{"title":"dos游戏","text":"dos游戏是以前的磁盘游戏现在有个网站把这些游戏收录了起来，这些游戏都是童年的回忆。 https://dos.zczc.cz/ #这里面的游戏都是在线玩的","path":"2018/09/14/duwen/"},{"title":"about me","text":"email:113021075899@163.com qq:11072869850 我用这个博客来记录一点我的东西，毕竟很多东西需要多回顾座右铭:你不是我，怎知我走过的路，心中的苦与乐。","path":"2018/09/13/about-me/"},{"title":"第一篇博客","text":"这个主要是一个博客发表内容的主要步骤，以及如何链接到hexo所需的文件 Quick Start创建一个md文件，来添加新的内容1$ hexo new \"My New Post\" 创建后md文件会在hexo文件下的source的_posts里面 更多的功能: Writing 运行自己的hexo-server1$ npm install hexo-server --save Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用1$ hexo server 安装完成后，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。1$ hexo server -p 5000 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下： 更多的功能: Server 使用Hexo生成静态文件1$ hexo generate 监视文件变动1$ hexo generate --watch Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。完成对文件等内容的修改，进行网页的完成后部署，上传上去您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。12$ hexo generate --deploy$ hexo deploy --generate 简写上面两个命令可以简写为12$ hexo g -d$ hexo d -g 也可以分成两步12$ hexo g $ hexo d 更多的功能: Generating 快速部署功能，一条命令就能将网站部署到服务器上1$ hexo deploy 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：12deploy: type: git 更多的功能: Deployment","path":"2018/09/12/hello-world/"}]}