{"pages":[],"posts":[{"title":"删除链表中满足区间值的结点","text":"描述利用单链表表示一个递增的整数序列，删除链表中值大于等于mink且小于等于maxk的所有元素（mink和maxk是给定的两个参数，其值可以和表中的元素相同，也可以不同）。 输入多组数据，每组数据有两行，第一行为链表的长度n，第二行为链表的n个元素（元素之间用空格分隔），第三行为给定的mink和maxk（用空格分隔）。当n=0时输入结束。 输出对于每组数据分别输出一行，依次输出删除元素后的链表元素，元素之间用空格分隔。 样例输入1 复制51 2 3 4 52 462 4 6 8 10 123 50样例输出11 52 6 8 10 12123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;#define OK 1using namespace std;typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode,*LinkList;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;/* void DeleteMinMax(LinkList &amp;L,int mink,int maxk) //自己的解法，没有老师的简便和合理 &#123; LNode *p=L-&gt;next; LNode *t1=L,*t2=L-&gt;next;//暂时记录位置的指针 ,这个一定要注意初始化，不然可能会造成空指针，由于第一个节点可能被删除 LNode *t;//暂时记录位置 while(p-&gt;data&lt;mink) &#123; t1=p; p=p-&gt;next; &#125; while(p) //比较关键的一步 &#123; if(p-&gt;data&lt;=maxk) t2=p; p=p-&gt;next; &#125; t1-&gt;next=t2-&gt;next; //连接 p=t1-&gt;next; while(p!=(t2-&gt;next)) //关键步骤 &#123; t=p; p=p-&gt;next; delete t; &#125; &#125;*/ void DeleteMinMax(LinkList &amp;L,int mink,int maxk)//官方解法 &#123; LNode *pre=L; // LNode *p=L-&gt;next; LNode *q,*s;//暂时指针 while(p&amp;&amp;p-&gt;data&lt;mink) &#123; pre=p; p=p-&gt;next; &#125; while(p&amp;&amp;p-&gt;data&lt;=maxk) &#123; p=p-&gt;next; &#125; q=pre-&gt;next; pre-&gt;next=p;//连接完成，接下来是delete。 while(q!=p) &#123; s=q; q=q-&gt;next; delete s; &#125; &#125; int main()&#123; int num; while(cin&gt;&gt;num&amp;&amp;num!=0) &#123; LinkList L; InintList(L); LNode *p; LNode *r; r=L; for(int i=1;i&lt;=num;i++) &#123; p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=NULL; r-&gt;next=p; r=p; &#125; int mink,maxk; cin&gt;&gt;mink&gt;&gt;maxk; DeleteMinMax(L,mink,maxk); p=L-&gt;next; cout&lt;&lt;p-&gt;data; p=p-&gt;next; while(p) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;data; p=p-&gt;next; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;","path":"2018/10/22/10-22-8/"},{"title":"链表的逆转(前插法逆转)","text":"描述利用单链表表示一个整数序列，通过一趟遍历，将单链表中所有结点的链接方向逆转。要求空间复杂度为O(1)。 输入多组数据，每组数据有两行，第一行为链表的长度n，第二行为链表的n个元素（元素之间用空格分隔）。当n=0时输入结束。 输出对于每组数据分别输出一行，逆序输出链表中的元素，元素之间用空格分隔。 样例输入1 复制51 2 3 4 563 1 2 5 4 60样例输出15 4 3 2 16 4 5 2 1 312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#define OK 1using namespace std;typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode,*LinkList;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;void Inverse(LinkList &amp;L)//前插法逆转 &#123; LNode *p=L-&gt;next; L-&gt;next=NULL; LNode *t;//暂时指针 while(p) &#123; t=p-&gt;next; p-&gt;next=L-&gt;next; L-&gt;next=p; p=t; &#125;&#125;int main()&#123; int num; while(cin&gt;&gt;num&amp;&amp;num!=0) &#123; LinkList L; InintList(L); LNode *p; LNode *r; r=L; for(int i=1;i&lt;=num;i++) &#123; p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=NULL; r-&gt;next=p; r=p; &#125; Inverse(L); p=L-&gt;next; cout&lt;&lt;p-&gt;data; p=p-&gt;next; while(p) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;data; p=p-&gt;next; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;","path":"2018/10/22/10-22-7/"},{"title":"基于链表的两个非递减有序序列的合并(精修版本，完美版本)","text":"描述给定两个非递减的整数序列A和B，利用链表表示序列A和B，将A和B合并为一个非递增的有序序列C，序列C允许有重复的数据。要求空间复杂度为O(1)。 输入多组数据，每组数据有三行，第一行为序列A和B的长度n和m，第二行为序列A的n个元素，第三行为序列B的m个元素（元素之间用空格分隔）。n=0且m=0时输入结束。 输出对于每组数据输出一行，为合并后的序列，每个数据之间用空格分隔。 样例输入1 复制5 51 3 5 7 92 4 6 8 105 61 2 2 3 52 4 6 8 10 120 0样例输出110 9 8 7 6 5 4 3 2 112 10 8 6 5 4 3 2 2 2 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;#define OK 1using namespace std;typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode,*LinkList;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;void MergeList(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)&#123; LNode *pa; LNode *pb; LNode *q;//暂时存储指针 pa=La-&gt;next; pb=Lb-&gt;next; Lc=La; Lc-&gt;next=NULL;//不可以省略，pa已经保存了La-&gt;next,没有关系了 while(pa||pb) &#123; if(!pa) //La表为空，对Lb表处理 &#123; q=pb-&gt;next; pb-&gt;next=Lc-&gt;next; Lc-&gt;next=pb; pb=q; &#125; else if(!pb) &#123; q=pa-&gt;next; pa-&gt;next=Lc-&gt;next; Lc-&gt;next=pa; pa=q; &#125; else if(pa-&gt;data&lt;=pb-&gt;data) &#123; q=pa-&gt;next; pa-&gt;next=Lc-&gt;next; Lc-&gt;next=pa; pa=q; &#125; else &#123; q=pb-&gt;next; pb-&gt;next=Lc-&gt;next; Lc-&gt;next=pb; pb=q; &#125; &#125; delete Lb;&#125;int main()&#123; int num1,num2; while(cin&gt;&gt;num1&gt;&gt;num2&amp;&amp;!(num1==0&amp;&amp;num2==0)) &#123; LinkList L; LinkList S; LinkList T; InintList(L); InintList(S); LNode *p; LNode *r; r=L; for(int i=1;i&lt;=num1;i++) &#123; p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=NULL; r-&gt;next=p; r=p; &#125; r=S; for(int i=1;i&lt;=num2;i++) &#123; p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=NULL; r-&gt;next=p; r=p; &#125; MergeList(L,S,T); p=T-&gt;next; cout&lt;&lt;p-&gt;data; p=p-&gt;next; while(p) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;data; p=p-&gt;next; &#125; cout&lt;&lt;endl;&#125; return 0;&#125;","path":"2018/10/22/10-22-3/"},{"title":"将两个递增链表合并为一个递增链表（最终版，利用所有已有链表空间，且释放掉其他空间，且用后插法创建链表）","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#define OK 1using namespace std;typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode,*LinkList;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;void MergeList(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)&#123; LNode *pa,*pb,*pc,*q;//q是暂时中间体指针 pa=La-&gt;next; pb=Lb-&gt;next; Lc=La;//用La的节点做Lc的节点，不再创建新的节点。（为了不开辟新的空间来放Lc的头节点） pc=Lc; while(pa&amp;&amp;pb) &#123; if(pa-&gt;data&lt;pb-&gt;data) &#123; pc-&gt;next=pa; pc=pa; pa=pa-&gt;next; &#125; else if(pa-&gt;data&gt;pb-&gt;data) &#123; pc-&gt;next=pb; pc=pb; pb=pb-&gt;next; &#125; else //相等时,取一个，删除掉一个 ,也就是delete &#123; pc-&gt;next=pa; pc=pa; pa=pa-&gt;next; q=pb-&gt;next; delete pb; pb=q; &#125; &#125; pc-&gt;next=pa?pa:pb;//之后一段直接继承。 delete Lb;//释放掉Lb的头节点占用的空间，最后利用全部的空间，没有浪费。 &#125; int main()&#123; int num1,num2; cin&gt;&gt;num1&gt;&gt;num2; LNode *p1,*p2; LNode *r1,*r2; LinkList L;//创建头指针，没有创建头节点 LinkList S; LinkList T; InintList(L);//创建需要用的头节点 ，T不需要 InintList(S); r1=L; r2=S; LNode *p; for(int i=1;i&lt;=num1;i++)//后插法创立链表 &#123; p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=NULL; r1-&gt;next=p; r1=p; &#125; for(int i=1;i&lt;=num2;i++) &#123; p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=NULL; r2-&gt;next=p; r2=p; &#125; MergeList(L,S,T); p=T-&gt;next; while(p) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p=p-&gt;next; &#125; return 0;&#125;","path":"2018/10/22/10-22-2/"},{"title":"继续练习后插法建立链表（比自己的pre指针创建链表好吗？）","text":"123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#define OK 1using namespace std;typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode,*LinkList;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;int main()&#123; LinkList L; InintList(L); int num; cin&gt;&gt;num; LNode *r;//尾指针 LNode *p;//输入指针 r=L; for(int i=1;i&lt;=num;i++)//后插法创建指针 &#123; p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=NULL; r-&gt;next=p; r=p; &#125; p=L-&gt;next;//指向头结点 while(p) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p=p-&gt;next; &#125; return 0;&#125;","path":"2018/10/22/10-22-1/"},{"title":"查找链表中的最大值","text":"描述利用单链表表示一个整数序列，通过一趟遍历在单链表中确定值最大的结点。 输入多组数据，每组数据有两行，第一行为链表的长度n，第二行为链表的n个元素（元素之间用空格分隔）。当n=0时输入结束。 输出对于每组数据分别输出一行，输出每个链表的最大值。 样例输入1 复制52 1 3 5 462 3 10 4 5 14-1 -2 -3 -40样例输出1510-1 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#define OK 1using namespace std;typedef struct LNode //这个LNode不能省略 &#123; int data; struct LNode *next;&#125;LNode,*LinkList;bool InitList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK; &#125; int main()&#123; int num; while(cin&gt;&gt;num&amp;&amp;num!=0) &#123; LinkList L; InitList(L); L-&gt;next=new LNode;//没有会报错 LNode *p=L-&gt;next; LNode *pre=L; for(int i=1;i&lt;=num;i++) &#123; cin&gt;&gt;p-&gt;data; p-&gt;next=new LNode; p=p-&gt;next; pre=pre-&gt;next; &#125; pre-&gt;next=NULL; LNode *max=L-&gt;next; p=L-&gt;next; while(p) &#123; if(max-&gt;data&lt;p-&gt;data) max=p; p=p-&gt;next; &#125; cout&lt;&lt;max-&gt;data&lt;&lt;endl; &#125;&#125;","path":"2018/10/22/10-22/"},{"title":"基于链表的两个非递减有序序列的合并","text":"注意：这道题利用了之前的逆序存储（链表）的方法注意细节，p3指针的应用 描述给定两个非递减的整数序列A和B，利用链表表示序列A和B，将A和B合并为一个非递增的有序序列C，序列C允许有重复的数据。要求空间复杂度为O(1)。 输入多组数据，每组数据有三行，第一行为序列A和B的长度n和m，第二行为序列A的n个元素，第三行为序列B的m个元素（元素之间用空格分隔）。n=0且m=0时输入结束。 输出对于每组数据输出一行，为合并后的序列，每个数据之间用空格分隔。 样例输入1 复制5 51 3 5 7 92 4 6 8 105 61 2 2 3 52 4 6 8 10 120 0样例输出110 9 8 7 6 5 4 3 2 112 10 8 6 5 4 3 2 2 2 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#define OK 1using namespace std;typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode,*LinkList;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;void mergelist(LinkList &amp;L,LinkList &amp;S,LinkList &amp;T)&#123; LNode *p1=L-&gt;next; LNode *p2=S-&gt;next; LNode *p3; while(p1&amp;&amp;p2) &#123; if(p1-&gt;data&lt;p2-&gt;data) &#123; p3=p1-&gt;next; p1-&gt;next=T-&gt;next; T-&gt;next=p1; p1=p3; &#125; else if(p1-&gt;data&gt;p2-&gt;data) &#123; p3=p2-&gt;next; p2-&gt;next=T-&gt;next; T-&gt;next=p2; p2=p3; &#125; else &#123; p3=p1-&gt;next; p1-&gt;next=T-&gt;next; T-&gt;next=p1; p1=p3; p3=p2-&gt;next; p2-&gt;next=T-&gt;next; T-&gt;next=p2; p2=p3; &#125; &#125; while(p1) &#123; p3=p1-&gt;next; p1-&gt;next=T-&gt;next; T-&gt;next=p1; p1=p3; &#125; while(p2) &#123; p3=p2-&gt;next; p2-&gt;next=T-&gt;next; T-&gt;next=p2; p2=p3; &#125;&#125;int main()&#123; LNode *p1; LNode *p2; int num1,num2; while(cin&gt;&gt;num1&gt;&gt;num2&amp;&amp;!(num1==0&amp;&amp;num2==0)) &#123; LinkList L; LinkList S; LinkList T; InintList(L); InintList(S); InintList(T); L-&gt;next=new LNode; S-&gt;next=new LNode; LNode *p1=L-&gt;next; LNode *pre1=L; LNode *p2=S-&gt;next; LNode *pre2=S; for(int i=1;i&lt;=num1;i++) &#123; cin&gt;&gt;p1-&gt;data; p1-&gt;next=new LNode; p1=p1-&gt;next; pre1=pre1-&gt;next; &#125; pre1-&gt;next=NULL; for(int i=1;i&lt;=num2;i++) &#123; cin&gt;&gt;p2-&gt;data; p2-&gt;next=new LNode; p2=p2-&gt;next; pre2=pre2-&gt;next; &#125; pre2-&gt;next=NULL; mergelist(L,S,T); LNode *p=T-&gt;next; cout&lt;&lt;p-&gt;data; p=p-&gt;next; while(p) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;data; p=p-&gt;next; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;","path":"2018/10/22/10-21-2/"},{"title":"查找链表中倒数第k个结点","text":"注意；技巧题，也就是双指针问题。描述利用单链表表示一个整数序列，请实现一个时间复杂度为O(n)、空间复杂度为O(1)的算法，通过一趟遍历在单链表中确定倒数第k个结点。 输入多组数据，每组数据有三行，第一行为链表的长度n，第二行为链表的n个元素（元素之间用空格分隔），第三行为k。当n=0时输入结束。 输出对于每组数据分别输出一行，输出每个链表的倒数第k个结点对应的数值。 样例输入1 复制75 2 3 4 50 100 703520 30 10 4 550样例输出150201234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define OK 1using namespace std;typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode,*LinkList;LNode *first;LNode *second;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;int main()&#123; int num; while(cin&gt;&gt;num&amp;&amp;num!=0) &#123; LinkList L; InintList(L); L-&gt;next=new LNode; LNode *p=L-&gt;next; LNode *pre=L; for(int i=1;i&lt;=num;i++) &#123; cin&gt;&gt;p-&gt;data; p-&gt;next=new LNode; p=p-&gt;next; pre=pre-&gt;next; &#125; pre-&gt;next=NULL; int position; cin&gt;&gt;position; first=L-&gt;next; second=L-&gt;next; for(int i=1;i&lt;=position;i++) &#123; first=first-&gt;next; &#125; while(first) &#123; first=first-&gt;next; second=second-&gt;next; &#125; cout&lt;&lt;second-&gt;data&lt;&lt;endl; &#125; return 0;&#125;","path":"2018/10/21/10-21-1/"},{"title":"基于链表的两个递增有序序列的合并","text":"注意,这题我一直由于没搞清指针和地址的差别而出问题 描述给定两个递增的整数序列A和B，利用链表表示序列A和B，将A和B合并为一个递增的有序序列C，序列C不允许有重复的数据。要求空间复杂度为O(1)。 输入多组数据，每组数据有三行，第一行为序列A和B的长度n和m，第二行为序列A的n个元素，第三行为序列B的m个元素（元素之间用空格分隔）。n=0且m=0时输入结束。 输出对于每组数据输出一行，为合并后的序列，每个数据之间用空格分隔。 样例输入1 复制5 51 3 5 7 92 4 6 8 103 41 5 91 2 5 90 0样例输出11 2 3 4 5 6 7 8 9 101 2 5 9 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#define OK 1using namespace std;typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode,*LinkList;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;void mergelist(LinkList &amp;L,LinkList &amp;S,LinkList &amp;T)&#123; LNode *p1=L-&gt;next; LNode *p2=S-&gt;next; //LNode *p3=T-&gt;next;//误区 LNode *p3=T;//因为要用next来串联 LNode *p4; while(p1&amp;&amp;p2) &#123; if(p1-&gt;data&lt;p2-&gt;data) &#123; /*p3=p1; p3=p3-&gt;next; p1=p1-&gt;next;*///始终要记住p3是一个指针，指向可以变，而每个指针的next才是真正不会变的 p3-&gt;next=p1; p3=p1; p1=p1-&gt;next; &#125; else if(p1-&gt;data&gt;p2-&gt;data) &#123; p3-&gt;next=p2; p3=p2; p2=p2-&gt;next; &#125; else &#123; p3-&gt;next=p1; p3=p1; p1=p1-&gt;next; p4=p2; p2=p2-&gt;next; delete p4; &#125; &#125; p3-&gt;next=p1?p1:p2; delete S;&#125;int main()&#123; LNode *p1; LNode *p2; int num1,num2; while(cin&gt;&gt;num1&gt;&gt;num2&amp;&amp;!(num1==0&amp;&amp;num2==0)) &#123; LinkList L; LinkList S; LinkList T; InintList(L); InintList(S); InintList(T); L-&gt;next=new LNode; S-&gt;next=new LNode; LNode *p1=L-&gt;next; LNode *pre1=L; LNode *p2=S-&gt;next; LNode *pre2=S; for(int i=1;i&lt;=num1;i++) &#123; cin&gt;&gt;p1-&gt;data; p1-&gt;next=new LNode; p1=p1-&gt;next; pre1=pre1-&gt;next; &#125; pre1-&gt;next=NULL; for(int i=1;i&lt;=num2;i++) &#123; cin&gt;&gt;p2-&gt;data; p2-&gt;next=new LNode; p2=p2-&gt;next; pre2=pre2-&gt;next; &#125; pre2-&gt;next=NULL; mergelist(L,S,T); LNode *p=T-&gt;next; cout&lt;&lt;p-&gt;data; p=p-&gt;next; while(p) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;data; p=p-&gt;next; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;","path":"2018/10/21/10-21/"},{"title":"后插法创建单链表（顺序存储）","text":"12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#define OK 1using namespace std;typedef struct LNode //这个LNode不能省略 &#123; int data; struct LNode *next;&#125;LNode,*LinkList;bool InitList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK; &#125; int main()&#123; LinkList L; InitList(L); LNode *p; LNode *last=L; //尾指针 for(int i=0;i&lt;5;i++) &#123; p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=NULL; last-&gt;next=p; //尾指针指向它 last=p; &#125; p=L-&gt;next; while(p) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;endl; p=p-&gt;next; &#125; return 0;&#125;","path":"2018/10/14/10-14-2/"},{"title":"后插法创建单链表(逆序存储)","text":"1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;#define OK 1using namespace std;typedef struct LNode //这个LNode不能省略 &#123; int data; struct LNode *next;&#125;LNode,*LinkList;bool InitList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK; &#125; int main()&#123; LinkList L; InitList(L); LNode *p; for(int i=0;i&lt;5;i++) &#123; p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=L-&gt;next; L-&gt;next=p; &#125; p=L-&gt;next; while(p) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;endl; p=p-&gt;next; &#125; return 0;&#125;","path":"2018/10/14/10-14-1/"},{"title":"数据结构栈的实现（顺序表）","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define MAXSIZE 100#define OK 1using namespace std;typedef struct&#123; char no[20]; char name[50]; double price;&#125;BOOK;typedef struct&#123; BOOK *base; BOOK *top; int stacksize;&#125;SqStack;bool InitStack(SqStack &amp;S)&#123; S.base=new BOOK[MAXSIZE]; if(!S.base) exit(0); S.top=S.base; S.stacksize=MAXSIZE; return OK; &#125;bool Push(SqStack &amp;S,BOOK e)&#123; if((S.top-S.base)==S.stacksize) return 0; *S.top++=e; return OK;&#125;bool Pop(SqStack &amp;S,BOOK &amp;e)&#123; if(S.top==S.base) return 0; e=*(--S.top); //栈顶元素出栈 return OK;&#125;BOOK GetTop(SqStack &amp;S)&#123; if(S.top!=S.base) return *(--S.top);&#125; int main()&#123; SqStack S; InitStack(S); BOOK p; while(cin&gt;&gt;p.no&gt;&gt;p.name&gt;&gt;p.price) &#123; if(p.no[0]==&apos;0&apos;&amp;&amp;p.name[0]==&apos;0&apos;&amp;&amp;fabs(p.price-0.0)&lt;1e-6) break; Push(S,p); &#125; p=GetTop(S); cout&lt;&lt;&quot;栈的最高的元素&quot;&lt;&lt;p.no&lt;&lt;&quot; &quot;&lt;&lt;p.name&lt;&lt;&quot; &quot;&lt;&lt;p.price&lt;&lt;endl; S.top++; BOOK pp; cout&lt;&lt;&quot;栈的每个元素&quot;&lt;&lt;endl; while(Pop(S,pp)) &#123; cout&lt;&lt;pp.no&lt;&lt;&quot; &quot;&lt;&lt;pp.name&lt;&lt;&quot; &quot;&lt;&lt;pp.price&lt;&lt;endl; &#125; return 0;&#125;","path":"2018/10/14/10-14/"},{"title":"多项式运算(北林oj)","text":"此题有很多点，比较麻烦，主要是自己确实想的比较简单，不过最终通过各种限制还是做出来了。描述据说每一个搞ACM的上辈子都是脑细胞死光钻到牛角尖里出不来的天使哦，可ACMer也会经常遇到些很简单的难题，比如a+b，找数列最大值……bluestone最近就遇到了这样的简单难题，Professor给她出了道一元多项式运算的题，但是bluestone做了一天没能做出来，于是她前来请教在座聪明的各位，看谁最先能帮bluestone解决这个problem？？她会灰常感激的哦~ bluestone给大家提个醒：类似以下式子的称为一元多项式： f(x)=ax^n+bx^m+……+k 如果给出x的值，我们马上就能算出f(x)了吧~ 输入输入第一行，是一个整数T(0&lt;T&lt;=100)，表示一共有T组测试数据，以下紧跟T组测试数据，每组第一行是一个X（0&lt;=X&lt;=10000），表示X的值；第二行是一个一元多项式，多项式的长度不会超过100。只进行多项式加减运算，保证最后运算的结果始终在int范围内，输入格式请参见样例。 输出每组测试数据输出占一行，输出最后的结果，具体格式请严格参考样例（注意空格） 样例输入1 复制222X^2+3X+13X+1样例输出1Case #1:15Case #2:4 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;algorithm&gt; using namespace std;string s;int deal(int x,int start,int end)&#123; if(start&gt;end)//处理特殊情况，处理+或-号在多项式最前端或最后端 return 0; int s1=1; //处理前面系数乘数，如果为省略1时则为1 int i=start; if(s[start]!=&apos;X&apos;) &#123;s1=s[start]-&apos;0&apos;; //如果不省略，记下大小 for(i=start+1;i&lt;=end&amp;&amp;s[i]!=&apos;X&apos;;i++) &#123; s1=s1*10+s[i]-&apos;0&apos;; &#125;&#125; int s2; if(s[i]==&apos;X&apos;||s[start]==&apos;X&apos;) //处理含有X的项时候默认为乘方1 s2=1; else s2=0; //不含有X，那X乘方为0 if((i+2)&lt;=end) //处理乘方数 s2=s[i+2]-&apos;0&apos;; for(int u=i+3;u&lt;=end;u++) &#123; s2=s2*10+s[u]-&apos;0&apos;; //乘方数大小 &#125; int s3=1; //如果X不存在，默认为1。如果乘方为0，默认也为1 while(s2--) //如果X存在，进行相关乘方处理 &#123; s3=s3*x; &#125; if(s1==0) //特殊情况乘数为0 return 0; else return s1*s3; &#125;int main()&#123; int n; cin&gt;&gt;n; int NUM=1; for(int i=1;i&lt;=n;i++) &#123; s.clear(); int x; cin&gt;&gt;x; cin&gt;&gt;s; int start=0; int end=0; int sum=0; int flag=1; //进行第一个符号处理设的 ,+为1，-为0 for(int u=0;u&lt;s.length();u++) &#123; if(s[u]==&apos;+&apos;||s[u]==&apos;-&apos;) // 遇到符号，对符号之前的式子处理 &#123; end=u-1; //定位之前的end if(flag) //式子之前的符号 &#123; sum+=deal(x,start,end); &#125; else &#123; sum-=deal(x,start,end); &#125; start=u+1; if(s[u]==&apos;+&apos;) //为下一个式子准备 flag=1; else flag=0; &#125; &#125; end=s.length()-1; //式子末尾特殊处理 if(flag) sum+=deal(x,start,end); else sum-=deal(x,start,end); printf(&quot;Case #%d:%d\\n&quot;,NUM,sum); NUM++; &#125; return 0;&#125;","path":"2018/10/12/10-12-1/"},{"title":"猴子选大王问题（循环链表和删除）","text":"描述一堆猴子都有编号，编号是1，2，3 …m，这群猴子（m个）按照1~m的顺序围坐一圈，从第1开始数，每数到第n个，该猴子就要离开此圈，这样依次下来，直到圈中只剩下最后一只猴子，则该猴子为大王。利用单向循环链表模拟此过程，依次输出出圈的猴子编号。 输入多组数据，每组数据占一行，包括两个数据m和n。m代表猴子个数，n代表步数，m=0且n=0时输入结束。 输出依次输出出圈的猴子编号，编号之间用空格隔开。 样例输入1 复制10 48 30 0样例输出14 8 2 7 3 10 9 1 6 53 6 1 5 2 8 4 7 其中有几点错误，这些错误应该在仔细分析后找到，但是自己总是异想天开。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define OK 1using namespace std;typedef struct &#123; int id;&#125;Houzhi;typedef struct LNode&#123; Houzhi data; struct LNode *next;&#125;LNode,*LinkList;LinkList L;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;int main()&#123; int n;//猴子数 int m;//步数 while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; InintList(L); L-&gt;next=new LNode; LNode *p=L-&gt;next; LNode *pre=L; if(n==0&amp;&amp;m==0) &#123; break; &#125; else &#123; for(int i=1;i&lt;=n;i++)//循环链表建立 &#123; p-&gt;data.id=i; p-&gt;next=new LNode; p=p-&gt;next; pre=pre-&gt;next; &#125; pre-&gt;next=L; //连接 &#125; int num=0; LNode *p2=L; LNode *pre2=pre; //尾节点 while(L!=L-&gt;next) //循环条件 &#123; for(int i=1;i&lt;=m;i++) &#123; p2=p2-&gt;next; if(pre2-&gt;next!=p2) //这个一定要判断，不然在删除结点后，pre2会和p2重叠 pre2=pre2-&gt;next; if(p2==L) //头节点的原因 &#123; p2=p2-&gt;next; pre2=pre2-&gt;next; &#125; &#125; num++; if(num&lt;n) cout&lt;&lt;p2-&gt;data.id&lt;&lt;&quot; &quot;; else if(num==n) &#123; cout&lt;&lt;p2-&gt;data.id&lt;&lt;endl;//这个endl易掉，不然过不了 &#125; pre2-&gt;next=p2-&gt;next; &#125; &#125; return 0;&#125;","path":"2018/10/12/10-12/"},{"title":"北林oj公司营收","text":"公司营收发布时间: 2018年3月22日 14:56 最后更新: 2018年3月22日 14:56 时间限制: 1000ms 内存限制: 128M 描述一些公司之间有合作关系，会计小张想了解大家的贸易额的多少。在这个问题中的各家公司都有一个固定的资产输出，而这些资产输出将被平均分给和这家公司有贸易公司的人。但是，这些公司中，有些公司的资产输出较多，有些则较少。给出小张要统计的公司名称（均小于20字符），给出每个公司的资产输出和与这家公司有贸易关系的公司列表，请确定每家公司贸易收入大于贸易支出的数量。 输入输入第1行为一个T，表示公司数量（2≤T≤10），输入第2~T+1行，表示所有的公司名称，每行对应一个公司名称。第T+2行到最后，为多组输入数据：每组中第一行为公司名，第二行包含两个数据，分别是第一行对应公司的贸易输出额度（0-4000），第二个数据是这家公司有贸易的公司数量K，接下来K行，每行分别写了这K个公司中的一个的名称。（对其余公司的贸易输出额度可以理解为输出总额度除以其余公司的数量取整，若除不尽，则多出来的额度不用算进贸易输出额度中） 输出输出T行，每行是一个公司名以及它的贸易收入比贸易支出多的额度，以空格隔开。 样例输入1 复制5KFCSubwayETSIntelAMD KFC200 3SubwayETSIntel ETS500 1KFC AMD150 2IntelETS Subway0 2AMDIntel Intel0 0样例输出1KFC 302Subway 66ETS -359Intel 141AMD -150 注意里面几个点，还是一道简单题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;struct gongshi&#123; string name; int ziran;&#125;go[12];int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;go[i].name; go[i].ziran=0; &#125; string s1; int sum; int m; string s2; int k=1; while(k&lt;=n&amp;&amp;cin&gt;&gt;s1)//这个k&lt;=n要在&amp;&amp;前面，不能在&amp;&amp;后面否则会很搞笑，由于执行的顺寻 &#123; cin&gt;&gt;sum&gt;&gt;m; k++; if(m==0)//m=0的情况要考虑 continue; int Sum=sum/m; int yushu=sum-Sum*m; for(int i=1;i&lt;=n;i++) &#123; if(go[i].name==s1) &#123; go[i].ziran=go[i].ziran+yushu-sum;//这里容易把之前的ziran忘记加 break; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;s2; for(int u=1;u&lt;=n;u++) &#123; if(go[u].name==s2) &#123; go[u].ziran+=Sum; break; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; cout&lt;&lt;go[i].name&lt;&lt;&quot; &quot;&lt;&lt;go[i].ziran&lt;&lt;endl; &#125; return 0;&#125;","path":"2018/10/11/10-11/"},{"title":"基于链存储结构的图书信息表的图书去重","text":"这道题有个continue会跳过for的第三段，是去重的关键描述出版社出版的任何一本图书的书号（ISBN）都是唯一的，即图书表中不允许包含书号重复的图书。定义一个包含图书信息（书号、书名、价格）的链表，读入相应的图书数据来完成图书信息表的创建（书号可能重复），然后进行图书的去重，即删除书号重复的图书（只保留第一本），最后输出去重后所有图书的信息。 输入总计输入n+1行，其中，第一行是图书数目n，后n行是n本图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，价格之后没有空格（书号可能重复）。其中书号和书名为字符串类型，价格为浮点数类型。 输出总计输出m+1行（m≤n），其中，第一行是去重后的图书数目，后m行是去重后图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，其中价格输出保留两位小数。 样例输入1 复制99787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.00样例输出189787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.0012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define OK 1using namespace std;typedef struct &#123; char no[20]; char name[50]; float price;&#125;Book;typedef struct LNode&#123; Book data; struct LNode *next;&#125;LNode,*LinkList;LinkList L;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;int main()&#123; int num; InintList(L); cin&gt;&gt;num; LNode *pre=L;//pre非常关键，这个是为了让链表最后一端为NULL for(int i=0;i&lt;num;i++) &#123; LNode *p=new LNode; scanf(&quot;%s%s%f&quot;,p-&gt;data.no,p-&gt;data.name,&amp;p-&gt;data.price); pre-&gt;next=p; pre=p; &#125; pre-&gt;next=NULL;//结尾加入NULL //之前创建的链表没有NULL节点，不太好，这里会有问题，但是现在有NULL了 LNode *it=L-&gt;next-&gt;next; pre=L-&gt;next; for(;it!=NULL;it=it-&gt;next,pre=pre-&gt;next) &#123; if(strcmp(pre-&gt;data.no,it-&gt;data.no)==0) &#123; pre-&gt;next=it-&gt;next; it=it-&gt;next; num--; continue;//这里会跳过接下来的操作，也就是说for第三段的也不执行 &#125; &#125; it=L-&gt;next; cout&lt;&lt;num&lt;&lt;endl; while(it) &#123; printf(&quot;%s %s %.2f\\n&quot;,it-&gt;data.no,it-&gt;data.name,it-&gt;data.price); it=it-&gt;next; &#125; return 0;&#125;","path":"2018/10/07/10-7-2/"},{"title":"基于链式存储结构的图书信息表的旧图书的出库","text":"描述定义一个包含图书信息（书号、书名、价格）的链表，读入相应的图书数据来完成图书信息表的创建，然后根据指定的待出库的旧图书的位置，将该图书从图书表中删除，最后输出该图书出库后的所有图书的信息。 输入总计n+2行。首先输入n+1行，其中，第一行是图书数目n，后n行是n本图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，价格之后没有空格。其中书号和书名为字符串类型，价格为浮点数类型。之后输入第n+2行，内容仅为一个整数，代表待删除的旧图书的位置序号。 输出若删除成功： 输出旧图书出库后所有图书的信息（书号、书名、价格），总计n-1行，每行是一本图书的信息，书号、书名、价格用空格分隔。其中价格输出保留两位小数。 若删除失败： 只输出以下一行提示：抱歉，出库位置非法！ 样例输入1 复制89787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.002样例输出19787302257646 Data-Structure 35.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.00 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define OK 1using namespace std;typedef struct &#123; char no[20]; char name[50]; float price;&#125;Book;typedef struct LNode&#123; Book data; struct LNode *next;&#125;LNode,*LinkList;LinkList L;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;int main()&#123; int num; InintList(L); cin&gt;&gt;num; LNode *pre=L;//pre非常关键，这个是为了让链表最后一端为NULL for(int i=0;i&lt;num;i++) &#123; LNode *p=new LNode; scanf(&quot;%s%s%f&quot;,p-&gt;data.no,p-&gt;data.name,&amp;p-&gt;data.price); pre-&gt;next=p; pre=p; &#125; pre-&gt;next=NULL; int position=0; cin&gt;&gt;position; pre=L; LNode *it=L-&gt;next; if(position&lt;=0||position&gt;=num) &#123; printf(&quot;Sorry, the storage location is illegal!\\n&quot;); &#125; else &#123;//之前创建的链表没有NULL节点，不太好，这里会有问题，但是现在有NULL了 for(int i=1;i&lt;=num;i++,pre=pre-&gt;next,it=it-&gt;next) &#123; if(i==position) &#123; pre-&gt;next=it-&gt;next; break; &#125; &#125; it=L-&gt;next; while(it) &#123; printf(&quot;%s %s %.2f\\n&quot;,it-&gt;data.no,it-&gt;data.name,it-&gt;data.price); it=it-&gt;next; &#125; &#125; return 0;&#125;","path":"2018/10/07/10-7-1/"},{"title":"基于链式存储结构的图书信息表的新图书的入库","text":"描述定义一个包含图书信息（书号、书名、价格）的链表，读入相应的图书数据来完成图书信息表的创建，然后根据指定的待入库的新图书的位置和图书的信息，将新图书插入到图书表中指定的位置上，最后输出新图书入库后的所有图书的信息。 输入总计n+3行。首先输入n+1行，其中，第一行是图书数目n，后n行是n本图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，价格之后没有空格。其中书号和书名为字符串类型，价格为浮点数类型。之后输入第n+2行，内容仅为一个整数，代表待入库的新图书的位置序号。最后输入第n+3行，内容为新图书的信息，书号、书名、价格用空格分隔。 输出若插入成功： 输出新图书入库后所有图书的信息（书号、书名、价格），总计n+1行，每行是一本图书的信息，书号、书名、价格用空格分隔。其中价格输出保留两位小数。 若插入失败： 只输出以下一行提示：抱歉，入库位置非法！ 此题纠正了之前链表创建，结尾没有NULL的问题，就是用一个pre前点指针。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define OK 1using namespace std;typedef struct &#123; char no[20]; char name[50]; float price;&#125;Book;typedef struct LNode&#123; Book data; struct LNode *next;&#125;LNode,*LinkList;LinkList L;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;int main()&#123; int num; InintList(L); cin&gt;&gt;num; LNode *pre=L;//pre非常关键，这个是为了让链表最后一端为NULL for(int i=0;i&lt;num;i++) &#123; LNode *p=new LNode; scanf(&quot;%s%s%f&quot;,p-&gt;data.no,p-&gt;data.name,&amp;p-&gt;data.price); pre-&gt;next=p; pre=p; &#125; pre-&gt;next=NULL; int position=0; cin&gt;&gt;position; pre=L; LNode *NEW=new LNode; LNode *it=L-&gt;next; scanf(&quot;%s%s%f&quot;,NEW-&gt;data.no,NEW-&gt;data.name,&amp;NEW-&gt;data.price); if(position&lt;=0||position&gt;=(num+1)) &#123; printf(&quot;Sorry, the storage location is illegal!\\n&quot;); &#125; else &#123;//之前创建的链表没有NULL节点，不太好，这里会有问题，但是现在有NULL了 for(int i=1;i&lt;=num+1;i++,pre=pre-&gt;next,it=it-&gt;next) &#123; if(i==position) &#123; pre-&gt;next=NEW; NEW-&gt;next=it; break; &#125; &#125; it=L-&gt;next; while(it) &#123; printf(&quot;%s %s %.2f\\n&quot;,it-&gt;data.no,it-&gt;data.name,it-&gt;data.price); it=it-&gt;next; &#125; &#125; return 0;&#125;","path":"2018/10/07/10-7/"},{"title":"基于链式存储结构的图书信息表的最爱图书的查找","text":"描述定义一个包含图书信息（书号、书名、价格）的链表，读入相应的图书数据来完成图书信息表的创建，然后根据指定的最爱图书的名字，查找最爱的图书，输出相应图书的信息。 输入总计n+m+2行。首先输入n+1行，其中，第一行是图书数目n，后n行是n本图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，价格之后没有空格。其中书号和书名为字符串类型，价格为浮点数类型。然后输入m+1行，其中，第一行是一个整数m，代表查找m次，后m行是每次待查找的最爱图书名字。 输出若查找成功： 总计输出m*（k+1）行，对于每一次查找，第一行是最爱图书数目（同一书名的图书可能有多本），后k行是最爱图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，其中价格输出保留两位小数。 若查找失败： 只输出以下提示：抱歉，没有你的最爱！ 样例输入1 复制89787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.002Java-Programming-LanguageData-Structure样例输出1Sorry，there is no your favourite!29787302257646 Data-Structure 35.009787302257800 Data-Structure 62.00123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define OK 1using namespace std;typedef struct &#123; char no[20]; char name[50]; float price;&#125;Book;typedef struct LNode&#123; Book data; struct LNode *next;&#125;LNode,*LinkList;LinkList L;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;int main()&#123; int num; InintList(L); cin&gt;&gt;num; LNode *p=new LNode; L-&gt;next=p; for(int i=0;i&lt;num;i++) &#123; scanf(&quot;%s%s%f&quot;,p-&gt;data.no,p-&gt;data.name,&amp;p-&gt;data.price); p-&gt;next=new LNode; p=p-&gt;next; &#125; int NUM=0; cin&gt;&gt;NUM; char NAME[50]; while(NUM--) &#123; LinkList S; InintList(S); scanf(&quot;%s&quot;,NAME); int count=0; LNode *p1=new LNode; S-&gt;next=p1; //LNode *p1=S-&gt;next; //有问题，这样写不够。要写 LNode *it=L-&gt;next; while(it) &#123; if(strcmp(it-&gt;data.name,NAME)==0) &#123; count++; strcpy(p1-&gt;data.no,it-&gt;data.no); strcpy(p1-&gt;data.name,it-&gt;data.name); p1-&gt;data.price=it-&gt;data.price; p1-&gt;next=new LNode; p1=p1-&gt;next; &#125; it=it-&gt;next; &#125; if(count==0) &#123; printf(&quot;Sorry，there is no your favourite!\\n&quot;); &#125; else &#123; cout&lt;&lt;count&lt;&lt;endl; LNode *p2=S-&gt;next; while(count--) &#123; printf(&quot;%s %s %.2f\\n&quot;,p2-&gt;data.no,p2-&gt;data.name,p2-&gt;data.price); p2=p2-&gt;next; &#125; &#125; &#125; return 0;&#125;","path":"2018/10/05/10-5-1/"},{"title":"基于链式存储结构的图书信息表的逆序存储","text":"描述定义一个包含图书信息（书号、书名、价格）的链表，读入相应的图书数据来完成图书信息表的创建，然后将读入的图书逆序存储，逐行输出逆序存储后每本图书的信息。 输入输入n+1行，第一行是图书数目n，后n行是n本图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，价格之后没有空格。其中书号和书名为字符串类型，价格为浮点数类型。 输出总计n行，第i行是原有图书表中第n-i+1行的图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔。其中价格输出保留两位小数。 样例输入1 复制89787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.00样例输出19787822234110 The-C-Programming-Language 38.009787811234923 Compiler-Principles 62.009787302257800 Data-Structure 62.009787810827430 Discrete-Mathematics 36.009787302203513 Database-Principles 36.009787302219972 Software-Engineer 32.009787302164340 Operating-System 50.009787302257646 Data-Structure 35.00查看隐藏信息 本题最开始没有理解题意，导致我先顺序存储，在进行逆序存储。没有任何思路，之后看了题解，发现原来最开始就是逆序存储。然后有一个优化，就是在循环里面定义LNode *p=new LNode。然后其他都还好。代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define OK 1using namespace std;typedef struct &#123; char no[20]; char name[50]; float price;&#125;Book;typedef struct LNode&#123; Book data; struct LNode *next;&#125;LNode,*LinkList;LinkList L;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;int main()&#123; int num; InintList(L); L-&gt;next=NULL; cin&gt;&gt;num; for(int i=0;i&lt;num;i++) &#123; LNode *p=new LNode; scanf(&quot;%s%s%f&quot;,p-&gt;data.no,p-&gt;data.name,&amp;p-&gt;data.price); p-&gt;next=L-&gt;next; L-&gt;next=p; &#125; LNode *it=L-&gt;next; while(it) &#123; printf(&quot;%s %s %.2f\\n&quot;,it-&gt;data.no,it-&gt;data.name,it-&gt;data.price); it=it-&gt;next; &#125; return 0;&#125;","path":"2018/10/05/10-5/"},{"title":"威海归来","text":"这篇感想就是小学生的纪实，没有营养，因为我特别想睡，现在。 国庆去了威海，见了高中的老同学张。和北理的高中同学蔡一起坐了高铁过去。一路上感受到和谐号302的速度，然后这一切确实让我非常激动。这次也算是真正意义上体验吧。路上蔡拿出一本书，一本福尔摩斯，真的让我很惊讶。确实高铁有放书的地方，为什么不去放书。就是这样，我最终决定下次我也要带书。假装看算法的我，最终还是看起了体育新闻。在路上也和蔡聊了很多。关于学习方面的，还有保研考研，还有未来的工作方向，真的也算是了解到很多名校的学习，让我受益匪浅，学习是非常重要的，当然还有很多其他方面。蔡是学武器和引信的，感觉以后找工作是非常好找的。非常对口，感觉蔡以后会非常厉害。但是学计算机的我，也会努力的，大家都很棒。蔡应该能保研吧，我是这样想的，他毕竟当年和我同卓，然后理综考了290高考，太强了。不说了，赶紧写完吧。去了威海之后，第一天我们还是非常激动的，兴奋的。我们爬了一座大山。这是威海大学的大山。上面有天文台，然后我们决定一直往上爬，然后终于爬到了顶上，遥看大海，真的很棒，然后大家流下了合照，非常有意思的表情包。然后….明天再写，太累了。","path":"2018/10/04/10-4/"},{"title":"基于链式存储结构的图书信息表的排序","text":"此题也花费一定的时间，不过确实加深了理解由于链表不能用sort，所以排序我就用了最笨的方法。然后此题特别搞笑，两个地方都要用降序。name和price，之前的顺序表就没有。。。之间需要定义一些记录量，来帮助断连。此题以后有更好的方法，会来更新。附上代码。 描述定义一个包含图书信息（书号、书名、价格）的链表，读入相应的图书数据完成图书信息表的创建，然后将图书按照价格降序排序，逐行输出排序后每本图书的信息。 输入输入n+1行，前n行是n本图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，价格之后没有空格。最后第n+1行是输入结束标志：0 0 0（空格分隔的三个0）。其中书号和书名为字符串类型，价格为浮点数类型。 输出总计n行，每行是一本图书的信息（书号、书名、价格），书号、书名、价格用空格分隔。其中价格输出保留两位小数。 样例输入1 复制9787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.000 0 0样例输出19787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787302164340 Operating-System 50.009787822234110 The-C-Programming-Language 38.009787810827430 Discrete-Mathematics 36.009787302203513 Database-Principles 36.009787302257646 Data-Structure 35.009787302219972 Software-Engineer 32.00 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define OK 1using namespace std;typedef struct &#123; char no[20]; char name[50]; float price;&#125;Book;typedef struct LNode&#123; Book data; struct LNode *next;&#125;LNode,*LinkList;LinkList L;LNode *pre;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;int main()&#123; InintList(L); LNode *p=new LNode; L-&gt;next=p; while(scanf(&quot;%s%s%f&quot;,p-&gt;data.no,p-&gt;data.name,&amp;p-&gt;data.price)) &#123; if(p-&gt;data.no[0]==&apos;0&apos;&amp;&amp;p-&gt;data.name[0]==&apos;0&apos;&amp;&amp;((p-&gt;data.price-0.0)&lt;1e-6)) &#123; break; &#125; else &#123; pre=p; p-&gt;next=new LNode; p=p-&gt;next; &#125; &#125; pre-&gt;next=NULL; LNode *it; float MAX; LNode *pp;//记录最大值的位置 LNode *j;//在每个位置遍历 LNode *q;//移动时候前面那一个，来记录，并进行连接 LNode *qq;//记录it前面的位置 for(j=L;j!=NULL;) &#123; MAX=j-&gt;next-&gt;data.price; //每次对MAX都要初始化 pp=j-&gt;next; //记录都要初始化 ，以防下面的for没有得到相关的值 qq=j; // 记录都要初始化，以防下面的for没有得到相关的值 for(it=j-&gt;next,q=j;it!=NULL;it=it-&gt;next,q=q-&gt;next) &#123; if(it-&gt;data.price&gt;MAX||((fabs(it-&gt;data.price-MAX)&lt;1e-6)&amp;&amp;strcmp(it-&gt;data.name,pp-&gt;data.name)&gt;0)) &#123; //根据题意发现价格按降序，价格相同，名称也按降序。 MAX=it-&gt;data.price; pp=it; qq=q; &#125; &#125; if(pp!=j-&gt;next) //进行节点更新，最大点到前面的位置，然后连接去掉最大点的两个点 &#123; qq-&gt;next=pp-&gt;next; pp-&gt;next=j-&gt;next; j-&gt;next=pp; &#125; j=pp; //循环下一次的条件 if(j-&gt;next==NULL) //比较关键的一点，设置跳出条件，不然程序会一直run下去，考虑最后一个点的情况。 &#123; break; &#125; &#125; it=L-&gt;next; while(it!=NULL) &#123; printf(&quot;%s %s %.2f\\n&quot;,it-&gt;data.no,it-&gt;data.name,it-&gt;data.price); it=it-&gt;next; &#125; return 0;&#125;","path":"2018/09/28/9-28/"},{"title":"基于链式存储结构的图书信息表的创建和输出","text":"描述定义一个包含图书信息（书号、书名、价格）的链表，读入相应的图书数据来完成图书信息表的创建，然后统计图书表中的图书个数，同时逐行输出每本图书的信息。 输入输入n+1行，其中前n行是n本图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，价格之后没有空格。最后第n+1行是输入结束标志：0 0 0（空格分隔的三个0）。其中书号和书名为字符串类型，价格为浮点数类型。 输出总计n+1行，第1行是所创建的图书表中的图书个数，后n行是n本图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔。其中价格输出保留两位小数。 样例输入1 复制9787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.000 0 0样例输出189787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.00 代码LinkList p与LNode *p等价L为头节点pre是保存上一个节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define OK 1using namespace std;typedef struct &#123; char no[20]; char name[50]; float price;&#125;Book;typedef struct LNode&#123; Book data; struct LNode *next;&#125;LNode,*LinkList;LinkList L;LNode *pre;bool InintList(LinkList &amp;L)&#123; L=new LNode; L-&gt;next=NULL; return OK;&#125;int main()&#123; int num=0; InintList(L); LNode *p=new LNode; L-&gt;next=p; while(scanf(&quot;%s%s%f&quot;,p-&gt;data.no,p-&gt;data.name,&amp;p-&gt;data.price)) &#123; if(p-&gt;data.no[0]==&apos;0&apos;&amp;&amp;p-&gt;data.name[0]==&apos;0&apos;&amp;&amp;((p-&gt;data.price-0.0)&lt;1e-6)) &#123; delete p; break; &#125; else &#123; pre=p; p-&gt;next=new LNode; p=p-&gt;next; num++; &#125; &#125; pre-&gt;next=NULL; cout&lt;&lt;num&lt;&lt;endl; LNode *it=L-&gt;next; while(it) &#123; printf(&quot;%s %s %.2f\\n&quot;,it-&gt;data.no,it-&gt;data.name,it-&gt;data.price); it=it-&gt;next; &#125; return 0;&#125;","path":"2018/09/27/9-26-1/"},{"title":"今天接着吧","text":"这几天有点忙，但是不是说没有时间写blog,其实这几天还是有很多东西用电脑记下来。所以今天会继续写一点。争取每天更新一点东西。 过去一直被拉着走，这次我想自己跑快点！加油！","path":"2018/09/27/9-26/"},{"title":"博客域名的使用","text":"DNS服务器DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。3.更改hexo 打开本地文件地址，在source文件夹下添加CHANGE文件（==注意 没有后缀名==），里面的内容为你的域名然后在你的仓库的代码里面的setting里面进行custom domain 里面加入你的审核通过的域名然后就可以了。还有你的阿里云里面的解析ip必须是ping了我的wenjishiwo.github.io获得的ip地址。相关的具体操作阿里云解释的都很清楚。 阿里云免费DNS其实就是万网原来自带的DNS系统，阿里云把万网收入囊中后改了一下DNS网页中文名字，连域名也懒得换了，直接套用万网的根域名，加一个DNS的二级域名然后就成了阿里云DNS了，前不久开放给了所有用户使用，非万网的用户也可以注册使用。 阿里云免费DNS域名解析服务支持A、CNAME、NS、MX、TXT、SRV、AAAA、URL等解析类型，新增解析记录，实时生效的，提供联通、电信、移动、教育网和海外线路的智能解析，URL转发功能目前只支持网站有BA号且接入商是万网的域名转发需求。 总得来说，万网被阿里云新的推广策略和新的形象包装成功实现了转型，建议国内那些传统IDC商们赶紧学着阿里云的做法，否则再过几年就晚了。 万网的dns都是只能自家的域名用,自从阿里收购了万网之后.在很多方便都有很大的发展,而阿里云dns就是一大成果,虽然目前处于发展状态,跟腾讯的DNSPOD还是有稍许的差距,以后或许会更强大吧,自从腾讯收购了dnspod推出很多收费套餐后,新用户的解析功能越来越不中用了.本来还有几个域名在dnspod不小心删除重新添加之后什么功能都没个毛线了.反正功能上都差不多,还不如尝试下阿里云的dns解析功能.DNS解析本质上差距不是很大,阿里的提供有免费的短信提醒,对于中型甚至大型网站来说提醒还是很有用的,而且阿里云提供有免费的100G硬防.对于dnspod来说,记得好像是只要有针对DNS解析的攻击就直接停掉域名了. 还有一个腾讯云的相关操作，这个我就不在做相关的理解了但是我可以提供相关的网址来进行更一步的学习。 dnspod是腾讯的，万网是阿里自带，dns服务器看你用哪个服务器帮你解析。 https://www.cnblogs.com/ryanleee/p/8274314.html 关于域名我还想再谈谈，就是之前我是再阿里云这个地方注册的域名。dns服务器国内有两个提供支持，一个是腾讯dnspod,一个是万网自带，这个万网就是阿里收购的dns服务器。上面的链接说明用dnspod来解析的，然后配置一个@和www的，意思是一个是wenji.site,一个是www.wenji.site之后由于在github的wenjishiwo.github.io仓库设置的是wenji.site,所以最后只能通过这个wen.site进行访问。以后我会试试用www的能否修改。下次再更新。发现没问题，修改后没问题。也可以用www.wenji.site来访问了。","path":"2018/09/24/9-24-6/"},{"title":"中秋节快乐","text":"","path":"2018/09/24/9-24-5/"},{"title":"基于顺序存储结构的图书信息表的图书去重","text":"描述出版社出版的任何一本图书的书号（ISBN）都是唯一的，即图书表中不允许包含书号重复的图书。定义一个包含图书信息（书号、书名、价格）的顺序表，读入相应的图书数据来完成图书信息表的创建（书号可能重复），然后进行图书的去重，即删除书号重复的图书（只保留第一本），最后输出去重后所有图书的信息。 输入总计输入n+1行，其中，第一行是图书数目n，后n行是n本图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，价格之后没有空格（书号可能重复）。其中书号和书名为字符串类型，价格为浮点数类型。 输出总计输出m+1行（m≤n），其中，第一行是去重后的图书数目，后m行是去重后图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，其中价格输出保留两位小数。 样例输入1 复制99787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.00样例输出189787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.00 ##这道题我写了一会，发现这道题有一个点易错。就是去重的条件的限制，L.length到底在循环中到底是-1还是不减，还有到底是&lt;还是&lt;=这个在条件中是很重要的。还有由于L.length要不断更新，因为这是很重要的一件事，不然没法做到所有的去重，不过我仍然认为我这是一个最暴力的解法，并不聪明。我是查到重之后，就进行一次前移。以后有更好的方法我会更新。 正确的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define MAXSIZE 1000#define OK 1#define ERROR 0using namespace std;typedef struct&#123; char no[20]; char name[50]; float price;&#125;Book;typedef struct&#123; Book *elem; int length;&#125;SqList;SqList L;int N;bool IninList(SqList &amp;L)&#123; L.elem = new Book[MAXSIZE]; if (!L.elem) exit(OVERFLOW); L.length = N; return OK;&#125;int main()&#123; cin&gt;&gt;N; IninList(L); for(int i=0;i&lt;N;i++) &#123; scanf(&quot;%s%s%f&quot;, L.elem[i].no, L.elem[i].name, &amp;L.elem[i].price); &#125; for(int i=0;i&lt;L.length-1;i++) &#123; Book book; book=L.elem[i]; for(int j=i+1;j&lt;L.length;j++) &#123; if(strcmp(book.no,L.elem[j].no)==0) &#123; for(int u=j;u&lt;L.length-1;u++) &#123; L.elem[u]=L.elem[u+1]; &#125; L.length--; &#125; &#125; &#125; cout&lt;&lt;L.length&lt;&lt;endl; for(int j=0;j&lt;=L.length-1;j++) printf(&quot;%s %s %.2f\\n&quot;,L.elem[j].no,L.elem[j].name,L.elem[j].price); delete[] L.elem; return 0;&#125;","path":"2018/09/24/9-24-4/"},{"title":"基于顺序存储结构的图书信息表的新图书的入库","text":"描述定义一个包含图书信息（书号、书名、价格）的顺序表，读入相应的图书数据来完成图书信息表的创建，然后根据指定的待入库的新图书的位置和信息，将新图书插入到图书表中指定的位置上，最后输出新图书入库后所有图书的信息。 输入总计n+3行。首先输入n+1行，其中，第一行是图书数目n，后n行是n本图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，价格之后没有空格。其中书号和书名为字符串类型，价格为浮点数类型。之后输入第n+2行，内容仅为一个整数，代表待入库的新图书的位置序号。最后输入第n+3行，内容为新图书的信息，书号、书名、价格用空格分隔。 输出若插入成功： 输出新图书入库后所有图书的信息（书号、书名、价格），总计n+1行，每行是一本图书的信息，书号、书名、价格用空格分隔。其中价格输出保留两位小数。 若插入失败： 只输出以下提示：抱歉，入库位置非法！ 样例输入1 复制79787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.0029787822234110 The-C-Programming-Language 38.00样例输出19787302257646 Data-Structure 35.009787822234110 The-C-Programming-Language 38.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.00 这道题最开始wa的时候，我以为是由于我没用英文，最后发现是由于没注意到插入的次序，也就是先后移之后在插入。而我先插入之后再后移，就会造成数据出现重复。 正确代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define MAXSIZE 1000#define OK 1#define ERROR 0using namespace std;typedef struct&#123; char no[20]; char name[50]; float price;&#125;Book;typedef struct&#123; Book *elem; int length;&#125;SqList;SqList L;int N;bool IninList(SqList &amp;L)&#123; L.elem = new Book[MAXSIZE]; if (!L.elem) exit(OVERFLOW); L.length = 0; return OK;&#125;int main()&#123; cin&gt;&gt;N; IninList(L); for(int i=0;i&lt;N;i++) &#123; scanf(&quot;%s%s%f&quot;, L.elem[i].no, L.elem[i].name, &amp;L.elem[i].price); L.length++; &#125; int position; Book book; cin&gt;&gt;position; scanf(&quot;%s%s%f&quot;, book.no, book.name, &amp;book.price); if(position&lt;1||position&gt;(L.length+1)) cout&lt;&lt;&quot;Sorry, the storage location is illegal!&quot;&lt;&lt;endl; else &#123; L.length++; for(int i=L.length-1;i&gt;=position;i--) &#123; L.elem[i]=L.elem[i-1]; &#125; L.elem[position-1]=book; &#125; for(int j=0;j&lt;L.length;j++) printf(&quot;%s %s %.2f\\n&quot;,L.elem[j].no,L.elem[j].name,L.elem[j].price); delete[] L.elem; return 0;&#125;","path":"2018/09/24/9-24-3/"},{"title":"基本编程知识（我不会的）","text":"##1c++中数据类型的转换一般分为隐含转换和强制转换两种；（1）隐含转换算术运算符 关系运算符 逻辑运算符赋值运算符等二元运算符要求两个运算符的类型一致，算术运算 关系运算中参与运算的类型不一致时要进行隐含转换，原则是将低类型转化成高类型(类型越高数据精度越高，double&gt;float&gt;unsigned long&gt;long int&gt;short&gt;char&gt;)这种转化是电脑自动完成，是安全的，数据精度没有损失;（2）强制转换一般涉及到将高类型转化成低类型时使用，不安全，可能在精度的损失，有两种方法1类型说明符（表达式）//c++强制转化符号2(类型说明符)表达式 //c强制转化符号;如 float z=7.56；int a；a=int（z）；或a=（int）z； ##2abs( )主要用于对求整数的绝对值，在“stdlib.h”(或 )头文件里面。而fabs( )主要是求精度要求更高的double ，float 型的绝对值，在头文件里。两者在只#include时都可以使用。 ##3strcmp()C/C++函数，比较两个字符串设这两个字符串为str1，str2，若str1==str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。","path":"2018/09/24/9-24-2/"},{"title":"基于顺序存储结构的图书信息表的排序","text":"描述定义一个包含图书信息（书号、书名、价格）的顺序表，读入相应的图书数据完成图书信息表的创建，然后将图书按照价格降序排序，逐行输出排序后每本图书的信息。 输入输入n+1行，前n行是n本图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，价格之后没有空格。最后第n+1行是输入结束标志：0 0 0（空格分隔的三个0）。其中书号和书名为字符串类型，价格为浮点数类型。 输出总计n行，每行是一本图书的信息（书号、书名、价格），书号、书名、价格用空格分隔。其中价格输出保留两位小数。 样例输入1 复制9787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.000 0 0样例输出19787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787302164340 Operating-System 50.009787822234110 The-C-Programming-Language 38.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257646 Data-Structure 35.009787302219972 Software-Engineer 32.00 这题我在dev和vs2010上交没问题，但是oj过不了，发现我校是G++4.3版本，于是我在sort的插件cmp里面加入const,于是代码就过了，还有，就是scanf可以直接换成cin输入，测试没问题。 过的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#define MAXSIZE 10000#define OK 1#define ERROR 0#define OVERFLOW -2using namespace std;typedef struct&#123; char no[20]; char name[50]; float price;&#125;Book;typedef struct&#123; Book *elem; int length;&#125;SqList;SqList L;bool IninList(SqList &amp;L)&#123; L.elem=new Book[MAXSIZE]; if(!L.elem) exit(OVERFLOW); L.length=0; return OK;&#125;int cmp(const Book &amp;a,const Book &amp;b)&#123; if(a.price&gt;b.price) return 1; else return 0;&#125;int main()&#123; IninList(L); int start=0; while(scanf(&quot;%s%s%f&quot;,L.elem[start].no,L.elem[start].name,&amp;L.elem[start].price)) &#123; if(L.elem[start].no[0]==&apos;0&apos;&amp;&amp;L.elem[start].name[0]==&apos;0&apos;&amp;&amp;(L.elem[start].price-0.0&lt;1e-6)) break; else &#123; start++; L.length++; &#125; &#125; sort(L.elem,L.elem+L.length,cmp); for(int i=0;i&lt;=L.length-1;i++) &#123; printf(&quot;%s %s %.2f\\n&quot;,L.elem[i].no,L.elem[i].name,L.elem[i].price); &#125; delete [] L.elem; return 0;&#125;","path":"2018/09/24/9-24-1/"},{"title":"基于顺序存储结构的图书信息表的创建和输出","text":"描述定义一个包含图书信息（书号、书名、价格）的顺序表，读入相应的图书数据来完成图书信息表的创建，然后统计图书表中的图书个数，同时逐行输出每本图书的信息。 输入输入n+1行，其中前n行是n本图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔，价格之后没有空格。最后第n+1行是输入结束标志：0 0 0（空格分隔的三个0）。其中书号和书名为字符串类型，价格为浮点数类型。 输出总计n+1行，第1行是所创建的图书表中的图书个数，后n行是n本图书的信息（书号、书名、价格），每本图书信息占一行，书号、书名、价格用空格分隔。其中价格输出保留两位小数。 样例输入1 复制9787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.000 0 0样例输出189787302257646 Data-Structure 35.009787302164340 Operating-System 50.009787302219972 Software-Engineer 32.009787302203513 Database-Principles 36.009787810827430 Discrete-Mathematics 36.009787302257800 Data-Structure 62.009787811234923 Compiler-Principles 62.009787822234110 The-C-Programming-Language 38.00 runtime代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define MAXSIZE 10000#define OK 1#define ERROR 0#define OVERFLOW -2using namespace std;typedef struct&#123; char no[20]; char name[50]; float price;&#125;Book;typedef struct&#123; Book *elem; int length;&#125;SqList;SqList L;bool IninList(SqList &amp;L)&#123; L.elem=new Book[MAXSIZE]; if(!L.elem) exit(OVERFLOW); L.length=0; return OK;&#125;int main()&#123; IninList(L); char a[20]; char b[20]; float c; int start=0; while(scanf(&quot;%s%s%f&quot;,&amp;a,&amp;b,&amp;c)&amp;&amp;strcmp(a,&quot;0&quot;)&amp;&amp;strcmp(b,&quot;0&quot;)&amp;&amp;c!=0) &#123; strcpy(L.elem[start].no,a); strcpy(L.elem[start].name,b); L.elem[start].price=c; L.length++; start++; &#125; cout&lt;&lt;L.length&lt;&lt;endl; for(int i=0;i&lt;=L.length-1;i++) &#123; printf(&quot;%s %s %.2f\\n&quot;,L.elem[i].no,L.elem[i].name,L.elem[i].price); &#125; return 0;&#125; 经过分析，可能是处理的不够合理，一个点是strcmp,还有个精度（关于0）问题，还有delete，，还有预定义OVERFLOE存在。最后这都不是主要问题，原来是b[20]开的小了，不细心啊。原题是name[50],最后改了就能过了。 然后还有就是虽然改了就能过，但是写的还是不好，下面是最终的严谨版本。不是说之前的思路有问题，只是代码吗，还是严谨点好。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define MAXSIZE 10000#define OK 1#define ERROR 0#define OVERFLOW -2using namespace std;typedef struct&#123; char no[20]; char name[50]; float price;&#125;Book;typedef struct&#123; Book *elem; int length;&#125;SqList;SqList L;bool IninList(SqList &amp;L)&#123; L.elem=new Book[MAXSIZE]; if(!L.elem) exit(OVERFLOW); L.length=0; return OK;&#125;int main()&#123; IninList(L); int start=0; while(scanf(&quot;%s%s%f&quot;,L.elem[start].no,L.elem[start].name,&amp;L.elem[start].price)) &#123; if(L.elem[start].no[0]==&apos;0&apos;&amp;&amp;L.elem[start].name[0]==&apos;0&apos;&amp;&amp;(L.elem[start].price-0.0&lt;1e-6)) break; else &#123; start++; L.length++; &#125; &#125; cout&lt;&lt;L.length&lt;&lt;endl; for(int i=0;i&lt;=L.length-1;i++) &#123; printf(&quot;%s %s %.2f\\n&quot;,L.elem[i].no,L.elem[i].name,L.elem[i].price); &#125; delete [] L.elem; return 0;&#125;","path":"2018/09/24/9-24/"},{"title":"博客页面显示问题","text":"更新一条：为了不让其自适应，也就是说博客内容的宽度不要超过这个最大宽度，所以之后的博客都以之前的宽度为准。关于博客页面在移动端和pc端的页面显示不全的解决方法真的非常搞笑的一件事情，我的博客在移动端和pc端会出现非常大的差异。由于hexo自身渲染的原因，而相关文件是用markdown语法来写，但是很多文件并不全是。除了md这个内容的文件外，页面还是要用到html的相关语句。但是与传统的html文件不同，这个是渲染生成index.html,所以找不到相关的html文件。有的html文件都是之前hexo渲染生成的临时文件，所以修改没有任何作用。之后我以为是代码的问题，主要是认为估计可能是display化后造成的边框溢出。最后通过google的开发者的调试模式，一直在调试具体两个模块的代码，不管如何调都是没法改变，由于是body主体已经将整个代码都display了，所以最后是很无奈的。之后通过百度和Google,发现这样的问题并不普遍。最后发现有关网页说，无论是电脑还是手机，要做到自适应屏幕，其实都是一样的。首先，在网页代码的头部，加入一行viewport标签viewport是网页默认的宽度和高度，上面这行代码的意思是，网页宽度默认等于屏幕宽度（width=device-width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。即让viewport的宽度等于物理设备上的真实分辨率，不允许用户缩放。之后我开始找有关渲染的原始文件，通过搜索关键字viewport,发现在Hexo\\themes\\有关theme\\layout_partial的header.ejs文件里面有相关的html代码，发现里面已经定义了这个标签，发现width=device-width这个条件 于是我将相关代码补全，然后没有用。最后，我仔细发现看来是这个标签的原因，这个标签是为了适配两种设备。于是我试了下将这 个标签去掉，让其自然显示，发现果然解决了问题。终于移动端和pc端都可以使用相关的所有功能。","path":"2018/09/23/jiejue/"},{"title":"今天是我的生日","text":"不知不觉到了自己的生日，想写点什么，毕竟感觉自己真的是不小了。今天收到来自同学们的祝福，内心还是挺开心的，大家平时互相帮助互相共事的情景还是非常快乐的。过生肯定首先要想到家人，我妈给我发个大红包，还是挺开心的。昨天还看了风语咒，感慨真的是家人带给我很多东西。今天生日收到我姐的月饼，也是非常开行，谢谢我姐对我的照顾，真的是太感谢我姐了。然后整个宿舍决定庆祝一下，最后点了肯德基来庆祝，还是非常有意思的，今天还没结束，但是我还是想写下来，晚上接着出去吃！到时候再来更新！","path":"2018/09/23/shenri/"},{"title":"风语咒","text":"今天在网上看了一下国产动漫电影《风语咒》，实话看了之后。感觉还是不错的，没想到剧情还是可以的。感觉国漫有希望了，和之前《大鱼海棠》比，是两种不同风格的电影。这个电影的很多特效技术，说实话也就是画风真的是国内的极致。虽然从中可以看到很多电影的影子，但是并没有落入俗套，看了之后，尤其对其中的感人情节记忆很深，让我也感受到这部片子想带给我的东西。真的不错，动漫迷真的可以看下。","path":"2018/09/22/tupian/"},{"title":"poj2377 最小生成树 负数化变成最大生成树 prime算法实践","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define INF 1&lt;&lt;30#define maxn 1010using namespace std;int G[maxn+1][maxn+1];int intree[maxn];int minweight[maxn];int sumweight;int flag=0;void chushihua()&#123; memset(intree,0,sizeof(intree)); memset(minweight,0,sizeof(minweight)); flag=0; for(int i=0;i&lt;maxn;i++) &#123; for(int j=0;j&lt;=maxn;j++) &#123; G[i][j]=INF; &#125; &#125; sumweight=0;&#125;void prime(int n)&#123; int node,Minweight; for(int i=1;i&lt;=n;i++) minweight[i]=G[1][i]; intree[1]=1; for(int i=2;i&lt;=n;i++) &#123; Minweight=INF; for(int j=1;j&lt;=n;j++) &#123; if(minweight[j]&lt;Minweight&amp;&amp;!intree[j]) &#123; Minweight=minweight[j]; node=j; &#125; &#125; intree[node]=1; sumweight+=Minweight; for(int j=1;j&lt;=n;j++) &#123; if(!intree[j]&amp;&amp;minweight[j]&gt;G[node][j]) &#123; minweight[j]=G[node][j]; &#125; &#125; &#125;&#125;int main()&#123; int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF) &#123; int a1,a2,v; chushihua(); for(int i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a1,&amp;a2,&amp;v); G[a1][a2]=-v; G[a2][a1]=-v; &#125; prime(n); for(int i=1;i&lt;=n;i++) &#123; if(intree[i]==0) &#123;flag=1; break;&#125; &#125; if(flag) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;,-sumweight); &#125; return 0; &#125;","path":"2018/09/21/du11/"},{"title":"hdu2066 Dijkstra 最短路 无向图版本 板子修改","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int map[1111][1111];int dis[1111];int book[1111];int maxn=1&lt;&lt;30;int main()&#123; int t,s,d; while(cin&gt;&gt;t&gt;&gt;s&gt;&gt;d) &#123; int minnn; for(int i=0;i&lt;=1110;i++) for(int j=0;j&lt;=1110;j++) if(i==j) map[i][j]=0; else map[i][j]=maxn; for(int i=1;i&lt;=t;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; map[a][b]=min(map[a][b],c); map[b][a]=map[a][b]; &#125; for(int i=0;i&lt;=1110;i++) book[i]=0; book[0]=1; for(int i=1;i&lt;=s;i++) &#123; int a; cin&gt;&gt;a; map[0][a]=map[a][0]=0; &#125; for(int i=0;i&lt;=1110;i++) &#123; dis[i]=map[0][i]; &#125; int u; for(int i=1;i&lt;=1110;i++) &#123; minnn=maxn; for(int j=1;j&lt;=1110;j++) &#123; if(book[j]==0&amp;&amp;dis[j]&lt;minnn) &#123; minnn=dis[j]; u=j; &#125; &#125; book[u]=1; for(int v=1;v&lt;=1110;v++) &#123; if(dis[v]&gt;dis[u]+map[u][v]&amp;&amp;!book[v]) dis[v]=dis[u]+map[u][v]; &#125; &#125; int minn=maxn; for(int i=1;i&lt;=d;i++) &#123; int a; cin&gt;&gt;a; minn=min(dis[a],minn); &#125; cout&lt;&lt;minn&lt;&lt;endl;&#125; return 0;&#125;","path":"2018/09/21/du10/"},{"title":"Dijkstra 最短路 有向图版本板子 无向图就是双重附边","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 #include &lt;stdio.h&gt; int main() &#123; int e[10][10],dis[10],book[10],i,j,n,m,t1,t2,t3,u,v,min; int inf=99999999; //用inf(infinity的缩写)存储一个我们认为的正无穷值 //读入n和m，n表示顶点个数，m表示边的条数 scanf(&quot;%d %d&quot;,&amp;n,&amp;m); //初始化 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) if(i==j) e[i][j]=0; else e[i][j]=inf; //读入边 for(i=1;i&lt;=m;i++) &#123; scanf(&quot;%d %d %d&quot;,&amp;t1,&amp;t2,&amp;t3); e[t1][t2]=t3; &#125; //初始化dis数组，这里是1号顶点到其余各个顶点的初始路程 for(i=1;i&lt;=n;i++) dis[i]=e[1][i]; //book数组初始化 for(i=1;i&lt;=n;i++) book[i]=0; book[1]=1; //Dijkstra算法核心语句 for(i=1;i&lt;=n-1;i++) &#123; //找到离1号顶点最近的顶点 min=inf; for(j=1;j&lt;=n;j++) &#123; if(book[j]==0 &amp;&amp; dis[j]&lt;min) &#123; min=dis[j]; u=j; &#125; &#125; book[u]=1; for(v=1;v&lt;=n;v++) &#123; if(e[u][v]&lt;inf) &#123; if(dis[v]&gt;dis[u]+e[u][v]) dis[v]=dis[u]+e[u][v]; &#125; &#125; &#125; //输出最终的结果 for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,dis[i]); getchar(); getchar(); return 0; &#125;/*可以输入以下数据进行验证。第一行两个整数 n m。n 表示顶点个数（顶点编号为 1~n），m 表示边的条数。接下来 m 行表示，每行有 3 个数 x y z。表示顶点 x 到顶点 y 边的权值为 z。 6 9 1 2 1 1 3 12 2 3 9 2 4 3 3 5 5 4 3 4 4 5 13 4 6 15 5 6 4运行结果是 0 1 8 4 13 17*/","path":"2018/09/21/du9/"},{"title":"线段树板子","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000010;int A[maxn];struct dian&#123; int l,r; int d; int lazy;&#125;sum[maxn&lt;&lt;2];void pushup(int rt)&#123; sum[rt].d=max(sum[rt&lt;&lt;1].d,sum[rt&lt;&lt;1|1].d);&#125;void build(int l,int r,int rt)&#123; sum[rt].l=l; sum[rt].r=r; sum[rt].d=0; sum[rt].lazy = 0; if(l!=r) &#123; int mid=(l+r)&gt;&gt;1; build(l,mid,rt&lt;&lt;1); build(mid+1,r,rt&lt;&lt;1|1); &#125;&#125;void xiachuan(int rt)&#123; sum[rt&lt;&lt;1].lazy+=sum[rt].lazy; sum[rt&lt;&lt;1|1].lazy+=sum[rt].lazy; sum[rt&lt;&lt;1].d+=sum[rt].lazy; sum[rt&lt;&lt;1|1].d+=sum[rt].lazy; sum[rt].lazy=0;&#125;void cha(int l,int r,int rt)&#123; if(sum[rt].l==l&amp;&amp;sum[rt].r==r) &#123; sum[rt].d++; sum[rt].lazy++; return; &#125; if(sum[rt].lazy) xiachuan(rt); int mid=(sum[rt].l+sum[rt].r)&gt;&gt;1; if(r&lt;=mid) cha(l,r,rt&lt;&lt;1); else if(l&gt;mid) cha(l,r,rt&lt;&lt;1|1); else &#123; cha(l,mid,rt&lt;&lt;1); cha(mid+1,r,rt&lt;&lt;1|1); &#125; pushup(rt);&#125;int query(int l,int r,int rt)&#123; if(sum[rt].l==l&amp;&amp;sum[rt].r==r) return sum[rt].d; if(sum[rt].lazy) xiachuan(rt); int mid=(sum[rt].r+sum[rt].l)&gt;&gt;1; if(r&lt;=mid) return query(l,r,rt&lt;&lt;1); else if(l&gt;mid) return query(l,r,rt&lt;&lt;1|1); else return max(query(l,mid,rt&lt;&lt;1),query(mid+1,r,rt&lt;&lt;1|1));&#125;int main()&#123; int k,m; int a,b; memset(A,0,sizeof(A)); scanf(&quot;%d%d&quot;,&amp;k,&amp;m); build(1,1000000,1); int id=0; for(int i=0;i&lt;m;i++) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); b--; if(query(a,b,1)&lt;k) &#123; A[id++]=i+1; cha(a,b,1); &#125; &#125; for(int i=0;i&lt;id;i++) printf(&quot;%d &quot;,A[i]); return 0;&#125;","path":"2018/09/21/du8/"},{"title":"contest1 hdu3635 drahonball 并查集升级版本 理解并查集基本概念和应用","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;//龙珠和城市都有区分 int gen[10010];//龙珠附属于某个城市 int num[10010];//龙珠移动次数 int rankk[10010];//所在城市的龙珠数int find(int x)&#123; int r=x; while(r!=gen[r]) &#123; num[r]+=num[gen[r]]; r=gen[r]; &#125; int i=x,j; while(i!=r) &#123; j=gen[i]; gen[i]=r; i=j; &#125;&#125; void join(int a,int b)&#123; int fx=find(a); int fy=find(b); if(fx!=fy) &#123; gen[fx]=fy; rankk[fy]+=rankk[fx]; num[fx]=1; &#125;&#125;int main()&#123; int N; cin&gt;&gt;N; int ttt=0; while(N--) &#123; int n,m; ttt++; cin&gt;&gt;n&gt;&gt;m; string caozuo; for(int i=1;i&lt;=n;i++) &#123; gen[i]=i; num[i]=0; rankk[i]=1; &#125; for(int i=1;i&lt;=m;i++) &#123; int a,b; cin&gt;&gt;caozuo; if(caozuo==&quot;T&quot;) &#123; cin&gt;&gt;a&gt;&gt;b; join(a,b); &#125; else &#123; cin&gt;&gt;a; int temp=find(a); cout&lt;&lt;&quot;Case &quot;&lt;&lt;ttt&lt;&lt;&quot;:&quot;&lt;&lt;endl&lt;&lt;temp&lt;&lt;&quot; &quot;&lt;&lt;rankk[temp]&lt;&lt;&quot; &quot;&lt;&lt;num[a]&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125;","path":"2018/09/21/du7/"},{"title":"并查集基础题hdu1232畅通工程详解附带模板","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt; using namespace std;int pre[1010];int flag[1010];//判断是否是根节点 int find(int x)&#123; int r=x; while(pre[r]!=r) &#123; r=pre[r]; &#125; int i=x; int j; while(i!=r) //路径压缩 &#123; j=pre[i]; pre[i]=r; i=j; &#125; return r;&#125;void join(int x,int y) //判断是否均为联通分支，并且进行合并 &#123; int fx=find(x); int fy=find(y); if(fx!=fy) &#123; pre[fx]=fy; &#125;&#125;int main()&#123; int N,M; int a,b; int total; while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)&amp;&amp;N) &#123; for(int i=1;i&lt;=N;i++) &#123; pre[i]=i; &#125; for(int i=1;i&lt;=M;i++) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); join(a,b); &#125; memset(flag,0,sizeof(flag)); for(int i=1;i&lt;=N;i++) &#123; int gen=find(i); flag[gen]=1; &#125; total=0; int shu=0;//根节点的数目 for(int i=1;i&lt;=N;i++) &#123; if(flag[i]) &#123; shu++; &#125; &#125; total=shu-1;//易错，不能写成shu--,因为运算的优先性 printf(&quot;%d\\n&quot;,total); &#125; return 0;&#125; contest1 rumor 并查集基础变式练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt; typedef long long ll;using namespace std;int pre[100010];ll gold[100010];int vis[100010];//判断是否是根节点 int find(int x)&#123; int r=x; while(pre[r]!=r) &#123; r=pre[r]; &#125; int i=x,j; while(i!=r) &#123; j=pre[i]; pre[i]=r;//易错，不是r=pre[i],而是pre[i]=r; i=j; &#125; return r;&#125;void join(int a,int b)&#123; int fx=find(a); int fy=find(b); if(fx!=fy) &#123; pre[fx]=fy; &#125;&#125;int main()&#123; int N,M; ll total; while(cin&gt;&gt;N&gt;&gt;M) &#123; for(int i=1;i&lt;=N;i++) &#123; cin&gt;&gt;gold[i];//lld的输入不用scanf,而是用cin,或者是%I64d这样。 &#125; for(int i=1;i&lt;=N;i++) &#123; pre[i]=i; &#125; for(int i=1;i&lt;=M;i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; join(a,b); &#125; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=N;i++) &#123; int gen=find(i); vis[gen]=1; gold[gen]=min(gold[gen],gold[i]);//本题易错，这里是一个易错点。 &#125; total=0; for(int i=1;i&lt;=N;i++) &#123; if(vis[i]) &#123; total+=gold[i]; &#125; &#125; cout&lt;&lt;total&lt;&lt;endl; &#125; return 0;&#125;","path":"2018/09/21/du6-1/"},{"title":"contest1 hdu1873优先队列的结构体应用题","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;class bingren&#123;public: int id; int youxianji; friend bool operator &lt; (const bingren &amp;a,const bingren &amp;b) //比较奇怪的一个地方，只有加上const 才可以过，也可以直接(bingren a,bingren b); &#123; if(a.youxianji!=b.youxianji) return a.youxianji&lt;b.youxianji; else return a.id&gt;b.id;&#125;&#125;;int num=0;int main()&#123; int N; while(cin&gt;&gt;N) &#123; num=0; priority_queue&lt;bingren&gt; q[4]; string s1; int a,b; while(N--) &#123; cin&gt;&gt;s1; if(s1==&quot;IN&quot;) &#123; cin&gt;&gt;a&gt;&gt;b; bingren tt; num++; tt.youxianji=b; tt.id=num; q[a].push(tt); //队列入队时push,不是input &#125; else &#123; cin&gt;&gt;a; if(!q[a].empty()) &#123; bingren tm=q[a].top(); q[a].pop(); cout&lt;&lt;tm.id&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;EMPTY&quot;&lt;&lt;endl; &#125; &#125; &#125; &#125; return 0; &#125;","path":"2018/09/21/du6/"},{"title":"set练习题","text":"丑数 优先队列和set查重count练习123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;set&gt;using namespace std;typedef long long ll;//此题易错是long long 不是int int main()&#123; ll n; int factor[3]=&#123;2,3,5&#125;; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; priority_queue&lt;ll,vector&lt;ll&gt;, greater&lt;ll&gt; &gt; q1; set&lt;ll&gt; q2; q1.push(1); q2.insert(1); ll i; for(i=1;;i++) &#123; ll m1=q1.top(); q1.pop(); if(i==n) &#123; printf(&quot;%lld\\n&quot;,m1); break; &#125; for(int j=0;j&lt;3;j++) &#123; ll m2=m1*factor[j]; if(!q2.count(m2)) &#123; q1.push(m2); q2.insert(m2); &#125; &#125; &#125; &#125; return 0;&#125; set对结构体排序的常见用法和排序插件cmp的用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;cstdio&gt;using namespace std;struct Student&#123; int id; string name;&#125;stu1,stu2,stu3;struct setcmp//set容器的插件,来确定set内部的排序 &#123; bool operator()(Student a,Student b) &#123; return a.id&gt;b.id; //这个大括号不可以省略，不然会报错的 &#125;&#125;;struct Setcmp&#123; bool operator()(Student a,Student b) &#123; return a.id&lt;b.id; &#125;&#125;; int main()&#123; set&lt;Student,setcmp&gt; my; set&lt;Student&gt;::iterator it; stu1.id=1000; stu2.id=2000; stu3.id=3000; stu1.name=&quot;ddd&quot;; stu2.name=&quot;www&quot;; stu3.name=&quot;aaa&quot;; my.insert(stu1); my.insert(stu2); my.insert(stu3); for(it=my.begin();it!=my.end();it++) &#123; cout&lt;&lt;it-&gt;id&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;name&lt;&lt;endl; &#125; set&lt;Student,Setcmp&gt; mm; mm.insert(stu1); mm.insert(stu2); mm.insert(stu3); for(it=mm.begin();it!=mm.end();it++) &#123; cout&lt;&lt;it-&gt;id&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;name&lt;&lt;endl; &#125; return 0;&#125; uva10815 set练习以及输入流sstream中的stringstream1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;string&gt; str; string s; while(cin&gt;&gt;s) &#123; for(int i=0;i&lt;s.length();i++) &#123; if(isalpha(s[i])) &#123; s[i]=tolower(s[i]); &#125; else &#123; s[i]=&apos; &apos;;//一个字符空格时&apos; &apos;不是&quot; &quot;; 输入的非字符转换为空格，作为单词的分界点 &#125; &#125; stringstream ss(s);//流 ; //构造时就写进，因为时对象的原因，将s加入ss流类里面,就类似于文件里面的输入文件一样 string s2; while(ss&gt;&gt;s2) &#123; str.insert(s2); &#125; &#125; for(set&lt;string&gt;::iterator it=str.begin();it!=str.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; return 0;&#125;","path":"2018/09/21/du5/"},{"title":"北大暑校","text":"我只是想谈一谈在北大暑校的事。 首先，说一下如何申请，先上北大暑校网站进行申请， 这里面你需要提供详细个人信息以及你的大学成绩单。 如果成绩还可以或是211或985院校，那么应该是很容易 审核通过，当然申请里面的表格等文件要填的越多越好， 来提高申请成功率。大概一周以内，你提交的申请就能 审核通过。 之后你就可以进行选课了，什么样的课都有，而且获得 的学分，拿会学校是基本认可的，也就是可以转到本校 教务系统。 我在暑校的感受是我是非常开心的，见到了视频里面才能见到的 大牛郭玮老师，然后品尝到了北大的食堂，然后还获得了 一个北大暑校证件，可以随时不用预约就能进北大校园。 想想还是挺不错的，虽然自己没学到啥，但是感受一下 国内知名顶尖高校的氛围还是不错的。而且我也亲眼见到 北大计算机获得各种奖状，而且在他们的机房参加了一次 考试，体验挺好。","path":"2018/09/20/beidashuxiao/"},{"title":"map和set","text":"##map 数据结构常见用法代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;iterator&gt;using namespace std;typedef map&lt;int,string,less&lt;int&gt; &gt;M_TYPE;//less greater 都是算子，针对键值来的 默认排序其实也就是key值的升序 ，也就是less&lt;int&gt; typedef M_TYPE::iterator M_IT;int main()&#123; M_TYPE Map; Map[1]=&quot;no.1&quot;; Map[2]=&quot;no.2&quot;; Map[3]=&quot;no.3&quot;; Map[4]=&quot;no.4&quot;; Map[5]=&quot;no.5&quot;; M_IT it=Map.find(2); cout&lt;&lt;&quot;map[2]是&quot;&lt;&lt;it-&gt;second&lt;&lt;endl; Map.insert(make_pair(2,&quot;new no.2&quot;));//不能改变已有的，可以添加没有的 Map.insert(make_pair(6,&quot;no.6&quot;)); Map.insert(pair&lt;int,string&gt;(7,&quot;no.7&quot;)); cout&lt;&lt;&quot;新的map[2]是&quot;&lt;&lt;it-&gt;second&lt;&lt;endl; M_IT is=Map.find(2); cout&lt;&lt;&quot;新的map[2]是&quot;&lt;&lt;is-&gt;second&lt;&lt;endl; it-&gt;second=&quot;new new no.2&quot;;//可以修改原有的 cout&lt;&lt;&quot;最新的map[2]是&quot;&lt;&lt;it-&gt;second&lt;&lt;endl; for(M_IT tt= Map.begin();tt!=Map.end();tt++) &#123; cout&lt;&lt;tt-&gt;second&lt;&lt;endl; &#125; Map.erase(2); cout&lt;&lt;endl; for(M_IT tt= Map.begin();tt!=Map.end();tt++) &#123; cout&lt;&lt;tt-&gt;second&lt;&lt;endl; &#125; cout&lt;&lt;endl; M_IT id=Map.find(5); Map.erase(id); for(M_IT tt= Map.begin();tt!=Map.end();tt++) &#123; cout&lt;&lt;tt-&gt;second&lt;&lt;endl; &#125; return 0;&#125; 水果hdu1263 map内部嵌套用法 简单例题123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;typedef map&lt;string,map&lt;string,int&gt; &gt; MA_P;typedef map&lt;string,int&gt; Ma_P;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; int o; cin&gt;&gt;o; string s1,s2; int k; map&lt;string,map&lt;string,int&gt; &gt;q; for(int i=0;i&lt;o;i++) &#123; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;k; q[s2][s1]+=k;//亲测双重map只能这样用，不能用q.insert(make_pair(s2,make_pair(s1,k)))和pair(XX); &#125; for(MA_P::iterator i=q.begin();i!=q.end();i++) &#123; cout&lt;&lt;i-&gt;first&lt;&lt;endl; for(Ma_P::iterator t=i-&gt;second.begin();t!=i-&gt;second.end();t++) &#123; cout&lt;&lt;&quot; |----&quot;&lt;&lt;t-&gt;first&lt;&lt;&quot;(&quot;&lt;&lt;t-&gt;second&lt;&lt;&quot;)&quot;&lt;&lt;endl; &#125; &#125; if(n&gt;0) cout&lt;&lt;endl; &#125; return 0;&#125; set数据结构常见用法1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;string&gt;strset; set&lt;string&gt;::iterator it; strset.insert(&quot;aa&quot;); strset.insert(&quot;bb&quot;); strset.insert(&quot;cc&quot;); strset.insert(&quot;dd&quot;); for(it=strset.begin();it!=strset.end();it++)//set默认排序为升序，也就是less &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; it=strset.begin(); cout&lt;&lt;&quot;set的第一个元素&quot;&lt;&lt;*it&lt;&lt;endl; it=strset.end(); it--; cout&lt;&lt;&quot;set的最后一个元素&quot;&lt;&lt;*it&lt;&lt;endl; cout&lt;&lt;strset.empty()&lt;&lt;endl; cout&lt;&lt;strset.size()&lt;&lt;endl; cout&lt;&lt;strset.max_size()&lt;&lt;endl;//容器可能包含的元素最大个数 return 0;&#125;","path":"2018/09/20/du4/"},{"title":"priority_queue 练习","text":"##代码 greater算子 #include #includeusing namespace std;class T{ public: int x,y,z; T(int a,int b,int c):x(a),y(b),z(c) { } };bool operator &gt;(const T &amp;t1,const T &amp;t2){ return t1.z&gt;t2.z;}int main(){ priority_queue&lt;T,vector,greater &gt; q; q.push(T(4,4,3)); q.push(T(2,2,5)); q.push(T(1,5,4)); q.push(T(3,3,6)); while(!q.empty()) { T t=q.top(); q.pop(); cout&lt;&lt;t.x&lt;&lt;” “&lt;&lt;t.y&lt;&lt;” “&lt;&lt;t.z&lt;&lt;endl; } return 0;} ##代码 less 算子 #include #includeusing namespace std;class T{ public: int x,y,z; T(int a,int b,int c):x(a),y(b),z(c) { } };bool operator &lt;(const T &amp;t1,const T &amp;t2){ return t1.z&lt;t2.z;}int main(){ priority_queue q; q.push(T(4,4,3)); q.push(T(2,2,5)); q.push(T(1,5,4)); q.push(T(3,3,6)); while(!q.empty()) { T t=q.top(); q.pop(); cout&lt;&lt;t.x&lt;&lt;” “&lt;&lt;t.y&lt;&lt;” “&lt;&lt;t.z&lt;&lt;endl; } return 0;}","path":"2018/09/19/du3-1/"},{"title":"搜索","text":"说起bfs和dfs模板，就是智闯迷宫http://www.bjfuacm.com/problem/62/题目：描述有一个N*M大小的矩阵迷宫，由字符 ’ . ’ 和 ‘ # ’ 组成。起点位于第一行第一列，终点位于最后一行最后一列。想要机智的闯迷宫当然是走最短路径啦！机智的你来算一算迷宫的最短路径吧！(起点为左上角，重点为右下角) 输入有多组测试每组测试第一行输入两个数字N，M（0 &lt; N,M &lt; 20），空格隔开。接下来N行输入N*M大小矩阵。只有字符 ‘ . ’ 和 ‘ # ’ 组成。 ‘ . ’ 表示可以走的路，‘ # ’ 表示高高的障碍物。 输出每组输出从起点到终点的最短路径长度（保证数据每组都有解） 样例输入1 复制3 3………样例输出14样例输入2 复制4 4…. #.##…. #.#.样例输出26 ##代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;using namespace std;char map[22][22];int vis[22][22];int n,m,t=0,l=420;int to[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;/*void dfs(int x,int y)&#123; int tx,ty; t++; for(int i=0;i&lt;4;i++) &#123; tx=x+to[i][0]; ty=y+to[i][1]; if(tx&lt;0||ty&lt;0||tx&gt;=n||ty&gt;=m||map[tx][ty]==&apos;#&apos;||vis[tx][ty]==1) continue; if(map[tx][ty]==&apos;.&apos;&amp;&amp;vis[tx][ty]==0) &#123;vis[tx][ty]=1; if((tx==n-1)&amp;&amp;(ty==m-1)&amp;&amp;t&lt;l) l=t; dfs(tx,ty); &#125; &#125; t--; &#125;*/struct node&#123; int x; int y;&#125;;queue&lt;node&gt;que;void bfs(int x,int y)&#123; struct node q; q.x=x; q.y=y; que.push(q); while(!que.empty()) &#123; q=que.front(); for(int i=0;i&lt;4;i++) &#123; q.x+=to[i][0]; q.y+=to[i][1]; if(q.x&lt;0||q.y&lt;0||q.x&gt;=n||q.y&gt;=m) &#123; continue; &#125; if(map[q.x][q.y]==&apos;#&apos;||vis[q.x][q.y]==1) continue; if(map[q.x][q.y]==&apos;.&apos;&amp;&amp;vis[q.x][q.y]==0) &#123;que.push(q); t++;&#125; if(q.x==n-1&amp;&amp;q.y==m-1) return ; &#125; que.pop(); &#125;&#125;*/int main()&#123; memset(vis,0,sizeof(vis)); while(cin&gt;&gt;n&gt;&gt;m)&#123; l=420; t=0; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;map[i][j]; dfs(0,0); if(n==1&amp;&amp;m==1) l=0; cout&lt;&lt;l&lt;&lt;endl;&#125; return 0;&#125;","path":"2018/09/18/du3/"},{"title":"随笔","text":"我准备整理记录一些以前做过的题，也是为了提醒自己。先从基础知识开始，就从搜索算法开始。","path":"2018/09/17/du2/"},{"title":"计协会长推荐的常用网址（实时更新）","text":"顶尖中文大学计算机专业课程体系https://study.163.com/curricula/cs.htm离散数学 北交大http://www.icourse163.org/course/NJTU-1002530017","path":"2018/09/16/search/"},{"title":"数学和编程","text":"一位大佬的理解（原文摘录）原文链接：https://www.yinwang.org/blog-cn/2015/07/04/math数学和编程好些人来信问我，要成为一个好的程序员，数学基础要达到什么样的程度？十八年前，当我成为大学计算机系新生的时候，也为同样的问题所困扰。面对学数学，物理等学科的同学，我感到自卑。经常有人说那些专业的知识更加精华一些，难度更高一些，那些专业的人毕业之后如果做编程工作，水平其实比计算机系毕业的还要高。直到深入研究程序语言之后，对这个问题我才得到了答案和解脱。由于好多编程新手遇到同样的困扰，所以我想在这里把这个问题详细的阐述一下。 数学并不是计算机科学的基础很多人都盲目的认为，计算机科学是数学的一个分支，数学是计算机科学的基础，数学是更加博大精深的科学。这些人以为只要学会了数学，编程的事情全都不在话下，然而事实却并非如此。 事实其实是这样的： 计算机科学根本不是数学，它只不过借用了非常少，非常基础的数学，比高中数学还要容易。所谓“高等数学”，并不是研究计算机科学必须的。你可以用计算机来做微积分计算，可是这时候你其实是在做数学工作，用计算机作为工具。你研究的并不是计算机科学。这就像你可以用计算机来设计建筑，但建筑学却不是计算机科学的基础。计算机是比数学更加基础的工具，就像纸和笔一样。计算机可以用来解决数学的问题，也可以用来解决不是数学的问题，比如工程的问题，艺术的问题，经济的问题，社会的问题等等。计算机科学是完全独立的学科。学习了数学和物理，并不能代替对计算机科学的学习。你必须针对计算机科学进行学习，才有可能成为好的程序员。数学家所用的语言，比起常见的程序语言（比如C++，Java）来说，其实是非常落后而蹩脚的设计。所谓“数学的美感”，其实大部分是夜郎自大。99% 的数学家都写不出像样的代码。数学是异常糟糕的语言这并不是危言耸听。如果你深入研究过程序语言的理论，就会发现其实数学家们使用的那些符号，其实是一种非常糟糕的程序语言。数学的理论很多是有用的，然而数学家门用于描述这些理论所用的语言，却是纷繁复杂，缺乏一致性，可组合性（composability），简单性，可用性。这也就是为什么大部分人看到数学就头痛。这不是他们不够聪明，而是数学语言的“设计”有问题。人们学习数学的时候，其实只有少部分时间在思考它的精髓，而大部分时间是在折腾它的语法。 举一个非常简单的例子。如果你说 cos2θ 表示 (cos θ)2，那么理所当然，cos-1θ 就应该表示 1/(cos θ) 了？可它偏偏不是！别被数学老师们的教条和借口欺骗啦，他们总是告诉你：“你应该记住这些！” 可是你想过吗：凭什么？ cos2θ 表示 (cos θ)2，而 cos-1θ，明明是一模一样的形式，表示的却是 arccos θ。一个是求幂，一个是调用反函数，风马不及，却写成一个样子。这样的语言设计混淆不堪，却喜欢以“约定俗成”作为借口。 如果你再多看一些数学书，就会发现这只是数学语言几百年累积下来的糟粕的冰山一角。数学书里尽是各种上标下标，带括号的上标下标，x，y，z，a，b，c，f，g，h，各种扭来扭去的希腊字母，希伯来字母…… 斜体，黑体，花体，双影体，……用不同的字体来表示不同的“类型”。很多符号的含义，在不同的子领域里面都不一样。有些人上一门数学课，到最后还没明白那些符号是什么意思。 直到今天，数学家们写书仍然非常不严谨。他们常犯的一个错误是把 x2 这样的东西叫做“函数”（function）。其实 x2 不是一个函数，它只是一个表达式。你必须同时指明“x 是参数”，加上 x2，才会成为一个函数。所以正确的函数写法其实看起来像这样：f(x) = x2。或者如果你不想给它一个名字，可以借用 lambda calculus 的写法，写成： λx.x2。 可是数学家们灰常的喜欢“约定俗成”。他们定了一些不成文的规矩是这样：凡是叫“x”的，都是函数的参数，凡是叫“y”的，都可能是一个函数…… 所以你写 x2 就可以表示 λx.x2，而不需要显式的写出“λx”。殊不知这些约定俗成，看起来貌似可以让你少写几个字，却造成了许许多多的混淆和麻烦。比如，你在 Mathematica 里面可以对 x2 + y 求关于x的导数，而且会得到 y’(x) + 2x 这样蹊跷的结果，因为它认为 y 可能是一个函数。更奇怪的是，如果你在后面多加一个 a，也就是对 x2 + y + a 求导，你会得到 2x！那么 y’(x) 到哪里去了？莫名其妙…… 相对而言，程序语言就严谨很多，所有的程序语言都要求你必须指出函数的参数叫什么名字。像 x2 这样的东西，在程序语言里面不是一个函数（function），而只是一个表达式（expression）。即使 JavaScript 这样毛病众多的语言都是这样。比如，你必须写： function (x) { return x * x }那个括号里的(x)，显式的声明了变量的名字，避免了可能出现的混淆。我不是第一个指出这些问题的人。其实现代逻辑学的鼻祖 Gottlob Frege 在一百多年以前就在他的论文“Function and Concept”里批评了数学家们的这种做法。可是数学界的表达方式直到今天还是一样的混乱。 很多人学习微积分都觉得困难，其实问题不在他们，而在于莱布尼兹（Leibniz）。莱布尼兹设计来描述微积分的语言（∫，dx, dy, …），从现代语言设计的角度来看，其实非常之糟糕，可以说是一塌糊涂。我不能怪莱布尼兹，他毕竟是几百年前的人了，他不知道我们现在知道的很多东西。然而古人的设计，现在还不考虑改进，反而当成教条灌输给学生，那就是不思进取了。 数学的语言不像程序语言，它的历史太久，没有经过系统的，考虑周全的，统一的设计。各种数学符号的出现，往往是历史上某个数学家有天在黑板上随手画出一些古怪的符号，说这代表什么，那代表什么，…… 然后就定下来了。很多数学家只关心自己那块狭窄的子领域，为自己的理论随便设计出一套符号，完全不管这些是否跟其它子领域的符号相冲突。这就是为什么不同的数学子领域里写出同样的符号，却可以表示完全不同的涵义。在这种意义上，数学的语言跟 Perl（一种非常糟糕的程序语言）有些类似。Perl 把各种人需要的各种功能，不加选择地加进了语言里面，造成语言繁复不堪，甚至连Perl的创造者自己都不能理解它所有的功能。 数学的证明，使用的其实也是极其不严格的语言——古怪的符号，加上含糊不清，容易误解的人类语言。如果你知道什么是 Curry-Howard Correspondence 就会明白，其实每一个数学证明都不过是一段代码。同样的定理，可以有许多不同版本的证明（代码）。这些证明有的简短优雅，有的却冗长繁复，像面条一样绕来绕去，没法看懂。你经常在数学证明里面看到“未定义的变量”，证明的逻辑也包含着各种隐含知识，思维跳跃，非常难以理解。很多数学证明，从程序的观点来看，连编译都不会通过，就别提运行了。 数学家们往往不在乎证明的优雅性。他们认为只要能证明出定理，你管我的证明简不简单，容不容易看懂呢。你越是看不懂，就越是觉得我高深莫测，越是感觉你自己笨！这种思潮到了编程的时候就显出弊端了。数学家写代码，往往忽视代码的优雅性，简单性，模块化，可读性，性能，数据结构等重要因素，认为代码只要能算出结果就行。他们把代码当成跟证明一样，一次性的东西，所以他们的代码往往不能满足实际工程的严格要求。 数学里最在乎语言设计的分支，莫过于逻辑学了。很多人（包括很多程序语言专家）都盲目的崇拜逻辑学家，盲目的相信数理逻辑是优雅美好的语言。在程序语言界，数理逻辑已经成为一种灾害，明明很容易就能解释清楚的语义，非得写成一堆稀奇古怪，含义混淆的逻辑公式。殊不知其实数理逻辑也是有很大的历史遗留问题和误区的。研究逻辑学的人经常遇到各种“不可判定”（undecidable）问题和所谓“悖论”（paradox），研究几十年也没搞清楚，而其实那些问题都是他们自己造出来的。你只需要把语言改一下，去掉一些不必要的功能，问题就没了。但逻辑学家们总喜欢跟你说，那是某天才老祖宗想出来的，多么多么的了不起啊，不能改！ 用一阶逻辑（first-order logic）这样的东西，你可以写出一些毫无意义的语句。逻辑老师们会告诉你，记住啦，这些是没有意义的，如果写出来这些东西，是你的问题！他们没有意识到，如果一个人可以用一个语言写出毫无意义的东西，那么这问题在于这个语言，而不在于这个人。一阶逻辑号称可以“表达所有数学”，结果事实却是，没有几个数学家真的可以用它表达很有用的知识。到后来，稍微明智一点的逻辑学家们开始研究这些老古董语言到底出了什么毛病，于是他们创造了 Model Theory 这样的理论。写出一些长篇大部头，用于“验证”这些逻辑语言的合理性。这些问题在我看来都是显而易见的，因为很多逻辑的语言根本就不是很好很有用的东西。去研究它们“为什么有毛病”，其实是白费力气。自己另外设计一个更好语言就完事了。 在我看来，除了现代逻辑学的鼻祖 Gottlob Frege 理解了逻辑的精髓，其它逻辑学家基本都是照本宣科，一知半解。他们喜欢把简单的问题搞复杂，制造一些新名词，说得玄乎其玄灵丹妙药似的。如果你想了解逻辑学的精华，建议你看看 Frege 的文集。看了之后你也许会发现，Frege 思想的精华，其实已经融入在几乎所有的程序语言里了。 编程是一门艺术从上面你也许已经明白了，普通程序员使用的编程语言，就算是 C++ 这样毛病众多的语言，其实也已经比数学家使用的语言好很多。用数学的语言可以写出含糊复杂的证明，在期刊或者学术会议上蒙混过关，用程序语言写出来的代码却无法混过计算机这道严格的关卡。因为计算机不是人，它不会迷迷糊糊的点点头让你混过去，或者因为你是大师就不懂装懂。代码是需要经过现实的检验的。如果你的代码有问题，它迟早会导致出问题。 计算机科学并不是数学的一个分支，它在很大程度上是优于数学，高于数学的。有些数学的基本理论可以被计算机科学所用，然而计算机科学并不是数学的一部分。数学在语言方面带有太多的历史遗留糟粕，它其实是泥菩萨过河，自身难保，它根本解决不了编程中遇到的实际问题。 编程真的是一门艺术，因为它符合艺术的各种特征。艺术可以利用科学提供的工具，然而它却不是科学的一部分，它的地位也并不低于科学。和所有的艺术一样，编程能解决科学没法解决的问题，满足人们新的需求，开拓新的世界。所以亲爱的程序员们，别再为自己不懂很多数学而烦恼了。数学并不能帮助你写出好的程序，然而能写出好程序的人，却能更好的理解数学。我建议你们先学编程，再去看数学。 如果你想了解更多关于数学语言的弊病以及程序语言对它们的改进，我建议你看看这个 Gerald Susman 的讲座。","path":"2018/09/15/ddd/"},{"title":"dos游戏","text":"dos游戏是以前的磁盘游戏现在有个网站把这些游戏收录了起来，这些游戏都是童年的回忆。 https://dos.zczc.cz/ #这里面的游戏都是在线玩的","path":"2018/09/14/duwen/"},{"title":"about me","text":"email:113021075899@163.com qq:11072869850 我用这个博客来记录一点我的东西，毕竟很多东西需要多回顾座右铭:你不是我，怎知我走过的路，心中的苦与乐。","path":"2018/09/13/about-me/"},{"title":"第一篇博客","text":"这个主要是一个博客发表内容的主要步骤，以及如何链接到hexo所需的文件 Quick Start创建一个md文件，来添加新的内容1$ hexo new \"My New Post\" 创建后md文件会在hexo文件下的source的_posts里面 更多的功能: Writing 运行自己的hexo-server1$ npm install hexo-server --save Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用1$ hexo server 安装完成后，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。1$ hexo server -p 5000 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下： 更多的功能: Server 使用Hexo生成静态文件1$ hexo generate 监视文件变动1$ hexo generate --watch Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。完成对文件等内容的修改，进行网页的完成后部署，上传上去您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。12$ hexo generate --deploy$ hexo deploy --generate 简写上面两个命令可以简写为12$ hexo g -d$ hexo d -g 也可以分成两步12$ hexo g $ hexo d 更多的功能: Generating 快速部署功能，一条命令就能将网站部署到服务器上1$ hexo deploy 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：12deploy: type: git 更多的功能: Deployment","path":"2018/09/12/hello-world/"}]}